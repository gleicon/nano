---
phase: v1.3-01
plan: "03"
type: execute
wave: 2
depends_on: ["v1.3-01-01"]
files_modified:
  - src/api/writable_stream.zig
autonomous: true

must_haves:
  truths:
    - "write() on a WritableStream with async sink returns a Promise that resolves when the sink drains"
    - "write() with a sync sink continues to resolve immediately (no regression)"
    - "backpressure: ready promise is pending while queue is above highWaterMark, resolves when queue drains"
    - "Two sequential write() calls with async sink execute in order (second waits for first sink to drain)"
  artifacts:
    - path: "src/api/writable_stream.zig"
      provides: "processWriteQueue with async sink detection and deferred resolution"
      contains: "isPromise"
  key_links:
    - from: "src/api/writable_stream.zig writerWrite"
      to: "processWriteQueue"
      via: "write() adds to queue, processWriteQueue calls sink.write()"
      pattern: "processWriteQueue"
    - from: "src/api/writable_stream.zig processWriteQueue"
      to: "sink return value Promise"
      via: "detect isPromise, chain .then() to resolve write resolver"
      pattern: "isPromise\\|_then\\|thenCallback"
---

<objective>
Extend WritableStream's `processWriteQueue` to detect when the underlying sink's `write()` returns a Promise (async sink). When async, defer resolving the write's Promise until the sink Promise resolves. Sync sinks continue to resolve immediately.

Purpose: Current `processWriteQueue` calls `write_fn.call()` and immediately resolves the write Promise regardless of whether the sink returned a Promise. This breaks async sinks — a write that returns a slow Promise appears to complete instantly, causing data loss and incorrect backpressure.
Output: Modified writable_stream.zig where async sinks are detected via `result.isPromise()` and write completion is deferred via V8 Promise chaining.

Note: This plan runs in parallel with plan-02 (both depend only on plan-01). No file overlap.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v1.3-01-async-foundation/v1.3-01-RESEARCH.md
@.planning/phases/v1.3-01-async-foundation/v1.3-01-01-SUMMARY.md
@src/api/writable_stream.zig
@src/js.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Async sink detection in processWriteQueue</name>
  <files>src/api/writable_stream.zig</files>
  <action>
Modify `processWriteQueue` to handle async sinks. The key change: after calling `write_fn.call()`, check if the return value is a Promise. If yes, chain `.then(resolve, reject)` callbacks; if no (sync sink), resolve immediately as before.

**Step 1: Add `isPromise` helper** (inline at top of file or inline in function):

V8 Promise objects have a `then` method. Check for it:
```zig
fn isPromise(val: v8.Value) bool {
    // A Promise is an object with a callable 'then' property
    // V8 has v8.Value.isPromise() — check if the binding exposes it.
    // If v8.Value.isPromise() exists in the Zig bindings, use that.
    // Otherwise, duck-type: isObject() and has a callable 'then'.
    return val.isPromise();
    // If not available: val.isObject() — then check for 'then' property callable
}
```

Search the V8 binding source for `isPromise`: `grep -r "isPromise" src/ vendor/ lib/ 2>/dev/null | head -20`

If `isPromise()` is available on `v8.Value`, use it directly. If not, duck-type by checking `val.isObject()`.

**Step 2: Add then-callback infrastructure:**

WritableStream needs to continue processing after the async sink resolves. Use JavaScript-level Promise chaining (compile and run a small JS function) rather than registering Zig callbacks (which require Persistent handle complexity).

Create a JS helper that wraps the continuation logic:
```zig
/// Called after async sink write resolves — continues the write queue
fn makeSinkThenHelper(isolate: v8.Isolate, context: v8.Context, stream: v8.Object, resolver: v8.PromiseResolver, chunk_size: usize, queue: v8.Array) void {
    // JavaScript: sinkPromise.then(() => { resolve(undefined); continueQueue(); }, (e) => { reject(e); errorStream(); })
    // We encode stream reference and resolver via JS closure using a factory function

    // Build JS code that, given (stream, resolverPromise), chains the sink promise
    // Approach: use a pre-compiled template, pass stream and resolver as arguments

    // Simpler approach: inject a resolve/reject JavaScript function and let JS handle the .then()
    // This leverages the already-working JS Promise infrastructure.

    _ = stream; _ = resolver; _ = chunk_size; _ = queue; _ = isolate; _ = context;
    // See implementation below
}
```

**Actual implementation approach — inline JS Promise chaining:**

In `processWriteQueue`, after calling `write_fn.call()`:

```zig
// After calling write_fn.call():
const write_result = write_fn.call(context, sv, &write_args);

// Check if sink returned a Promise
const result_is_promise = blk: {
    if (write_result) |wr| {
        break :blk wr.isPromise();
    }
    break :blk false;
};

if (result_is_promise) {
    // === ASYNC SINK PATH ===
    // Do NOT resolve the write promise now.
    // Chain a .then() on the sink promise to resolve write promise when sink drains.
    const sink_promise = write_result.?;

    // Use JS eval to chain: sinkPromise.then(onFulfilled, onRejected)
    // Pass stream, write resolver, and chunk_size as closure-captured values via JS function factory.

    // Store pending write context on stream so the event loop can check it:
    _ = js.setProp(stream, context, isolate, "_pendingSinkPromise", sink_promise);
    // Store resolver, chunk_size on stream for the continuation:
    _ = js.setProp(stream, context, isolate, "_pendingWriteResolver",
        js.objToValue(v8.Object{ .handle = @ptrCast(resolver_val.handle) }));
    _ = js.setProp(stream, context, isolate, "_pendingChunkSize",
        js.number(isolate, chunk_size));

    // Compile and run a JS wrapper that chains the promise
    const chain_code =
        \\(function(sinkPromise, stream, resolverObj, chunkSize) {
        \\  // Convert resolverObj back to promise resolver-like interface
        \\  // We stored the resolver as a plain object — need a different approach.
        \\  // Actually: create a new Promise that resolves when sink resolves.
        \\  // The write's promise resolver is stored on stream._pendingWriteResolver.
        \\  // But we can't easily resolve it from JS.
        \\  // Better approach: return a chained promise and store it.
        \\  return sinkPromise.then(function() {
        \\    // Signal Zig that sink completed by setting a flag
        \\    stream._sinkResolved = true;
        \\  }, function(err) {
        \\    stream._sinkError = String(err);
        \\    stream._sinkResolved = true;
        \\  });
        \\})
    ;
    // This JS-side approach sets _sinkResolved on the stream object.
    // The event loop tick (processEventLoop) then checks _sinkResolved and calls
    // a Zig function to finalize the write.

    // SIMPLER ALTERNATIVE: Use JS Promise.then with Zig callbacks via V8 Function.

    // RECOMMENDED IMPLEMENTATION:
    // Since WritableStream is already a JS object, create a JavaScript-level continuation
    // using V8's built-in Promise.then() API directly from Zig:

    // Get 'then' method from sinkPromise
    const sink_obj = v8.Object{ .handle = @ptrCast(sink_promise.handle) };
    const then_val = sink_obj.getValue(context, v8.String.initUtf8(isolate, "then")) catch {
        // Not a thenable — treat as sync
        goto_sync_path = true;
        break :result_is_promise;
    };

    if (!then_val.isFunction()) {
        goto_sync_path = true;
        break :result_is_promise;
    }

    const then_fn = v8.Function{ .handle = @ptrCast(then_val.handle) };

    // Create fulfillment and rejection callbacks using a JS factory
    // Capture stream, resolver, chunk_size via a JS eval:
    const cb_code =
        \\(function makeCallbacks(stream, chunkSize) {
        \\  function onFulfilled() {
        \\    // Mark sink as drained
        \\    stream._sinkDrained = true;
        \\    stream._sinkFailed = false;
        \\  }
        \\  function onRejected(err) {
        \\    stream._sinkDrained = true;
        \\    stream._sinkFailed = true;
        \\    stream._sinkError = String(err);
        \\  }
        \\  return [onFulfilled, onRejected];
        \\})
    ;
    const cb_fn_str = v8.String.initUtf8(isolate, cb_code);
    var cb_script = v8.Script.compile(context, cb_fn_str, null) catch {
        // fallback: resolve immediately
        goto_sync_path = true;
        break :result_is_promise;
    };
    const cb_factory_val = cb_script.run(context) catch {
        goto_sync_path = true;
        break :result_is_promise;
    };
    const cb_factory = v8.Function{ .handle = @ptrCast(cb_factory_val.handle) };

    var cb_args: [2]v8.Value = .{
        js.objToValue(stream),
        js.number(isolate, chunk_size).toValue(),
    };
    const callbacks_arr_val = cb_factory.call(context, isolate.initUndefined().toValue(), &cb_args) orelse {
        goto_sync_path = true;
        break :result_is_promise;
    };
    const callbacks_arr = js.asArray(callbacks_arr_val);
    const on_fulfilled = js.getIndex(callbacks_arr.castTo(v8.Object), context, 0) catch {
        goto_sync_path = true;
        break :result_is_promise;
    };
    const on_rejected = js.getIndex(callbacks_arr.castTo(v8.Object), context, 1) catch {
        goto_sync_path = true;
        break :result_is_promise;
    };

    // Chain: sinkPromise.then(onFulfilled, onRejected)
    var then_args: [2]v8.Value = .{on_fulfilled, on_rejected};
    _ = then_fn.call(context, sink_promise, &then_args);

    // Set stream state to "waiting for sink"
    _ = js.setProp(stream, context, isolate, "_writing", js.boolean(isolate, true));
    _ = js.setProp(stream, context, isolate, "_sinkDrained", js.boolean(isolate, false));
    _ = js.setProp(stream, context, isolate, "_sinkFailed", js.boolean(isolate, false));

    // Return WITHOUT resolving write resolver — continuation will do it
    // Do NOT call js.ret(ctx, promise) yet — caller already set it before processWriteQueue
    return;

} else {
    // === SYNC SINK PATH (existing behavior) ===
    // Resolve immediately (existing code)
    const resolver = v8.PromiseResolver{ .handle = @ptrCast(resolver_val.handle) };
    _ = resolver.resolve(context, js.undefined_(isolate).toValue());
    // ... (rest of existing sync resolution code)
}
```

**Step 3: Add `checkAsyncSinkCompletion` — called during event loop processing:**

After the JS microtasks run (which will invoke `onFulfilled` or `onRejected`), the `_sinkDrained` flag is checked:

```zig
/// Check if an async sink has completed and finalize the write if so.
/// Called after each processEventLoop tick.
pub fn checkAsyncSinkCompletion(isolate: v8.Isolate, context: v8.Context, stream: v8.Object) bool {
    const drained_val = js.getProp(stream, context, isolate, "_sinkDrained") catch return false;
    if (!drained_val.isBoolean() or !drained_val.isTrue()) return false;

    // Reset flag
    _ = js.setProp(stream, context, isolate, "_sinkDrained", js.boolean(isolate, false));

    // Check if sink failed
    const failed_val = js.getProp(stream, context, isolate, "_sinkFailed") catch {
        js.boolean(isolate, false).toValue();
        return true;
    };

    const resolver_val = js.getProp(stream, context, isolate, "_pendingWriteResolver") catch return true;
    const resolver = v8.PromiseResolver{ .handle = @ptrCast(resolver_val.handle) };

    if (failed_val.isTrue()) {
        // Sink failed — transition stream to errored, reject write promise
        _ = js.setProp(stream, context, isolate, "_state", js.string(isolate, "errored"));
        const err_val = js.getProp(stream, context, isolate, "_sinkError") catch
            js.string(isolate, "Sink write failed").toValue();
        _ = resolver.reject(context, err_val);
    } else {
        // Sink drained — resolve write promise
        _ = resolver.resolve(context, js.undefined_(isolate).toValue());
    }

    // Get chunk_size and update queue byte size
    const chunk_size_val = js.getProp(stream, context, isolate, "_pendingChunkSize") catch null;
    const chunk_size: usize = if (chunk_size_val) |csv| blk: {
        if (csv.isNumber()) break :blk @as(usize, @intFromFloat(csv.toF64(context) catch 0));
        break :blk 0;
    } else 0;

    // Remove first item from queue (the one we just processed)
    const queue_val = js.getProp(stream, context, isolate, "_queue") catch return true;
    if (queue_val.isArray()) {
        const queue = js.asArray(queue_val);
        const new_queue = js.array(isolate, 0);
        var qi: u32 = 1;
        while (qi < queue.length()) : (qi += 1) {
            const elem = js.getIndex(queue.castTo(v8.Object), context, qi) catch continue;
            _ = js.setIndex(new_queue.castTo(v8.Object), context, qi - 1, elem);
        }
        _ = js.setProp(stream, context, isolate, "_queue", new_queue);

        // Update queue byte size
        const curr_size_val = js.getProp(stream, context, isolate, "_queueByteSize") catch null;
        const curr_size: usize = if (curr_size_val) |csv| blk: {
            if (csv.isNumber()) break :blk @as(usize, @intFromFloat(csv.toF64(context) catch 0));
            break :blk 0;
        } else 0;
        _ = js.setProp(stream, context, isolate, "_queueByteSize",
            js.number(isolate, if (curr_size >= chunk_size) curr_size - chunk_size else 0));

        // Check ready promise
        const hwm_val = js.getProp(stream, context, isolate, "_highWaterMark") catch null;
        const hwm = if (hwm_val) |hv| (if (hv.isNumber()) hv.toF64(context) catch 1.0 else 1.0) else 1.0;
        if (@as(f64, @floatFromInt(new_queue.length())) <= hwm) {
            const rr_val = js.getProp(stream, context, isolate, "_readyResolver") catch null;
            if (rr_val) |rrv| {
                if (rrv.isObject()) {
                    const rr = v8.PromiseResolver{ .handle = @ptrCast(rrv.handle) };
                    _ = rr.resolve(context, js.undefined_(isolate).toValue());
                }
            }
        }
    }

    // Done writing, process next item
    _ = js.setProp(stream, context, isolate, "_writing", js.boolean(isolate, false));
    processWriteQueue(isolate, context, stream);
    return true;
}
```

**Integration:** Export `checkAsyncSinkCompletion` as `pub fn`. The script/server event loop calls this after each `processEventLoop` tick for any active WritableStream. Since WritableStreams are JS objects, the Zig side doesn't directly track them. The existing event loop already calls a `processEventLoop` function — add a hook there.

Look for where `processEventLoop` is defined: `grep -r "processEventLoop\|fn process" src/runtime/ src/server/ 2>/dev/null | head -20`

Wire it up: after JS microtask processing, call `writable_stream.checkAsyncSinkCompletion(...)` on any stream stored in a known global (or skip wiring and rely on the JS promise callbacks running microtasks that trigger the flags, then have a periodic poll).

Simplest working approach: The `onFulfilled` JS callback sets `_sinkDrained = true`. Since this runs as a microtask (via promise resolution), it executes during the existing `v8.performMicrotaskCheckpoint()` call (if NANO has one). If NANO doesn't call `performMicrotaskCheckpoint`, add it to the event loop tick. Then on the next tick, check `_sinkDrained` on the stream.

If the stream object isn't directly accessible from Zig, expose `checkAsyncSinkCompletion` and let the JS `onFulfilled` callback directly call `processWriteQueue` via a registered global Zig function (already a pattern in NANO for timers).

**Practical simplification:** Register a Zig-backed global function `__writableSinkContinue(stream)` that does the finalization. The JS `onFulfilled` closure calls `__writableSinkContinue(stream)`. This avoids the polling approach entirely.
  </action>
  <verify>
Build: `zig build 2>&1 | head -30`

Test async sink:
```javascript
// /tmp/test_async_sink.js
const results = [];
const stream = new WritableStream({
  write(chunk, controller) {
    return new Promise((resolve) => {
      setTimeout(() => {
        results.push(chunk);
        resolve();
      }, 10);
    });
  }
});

const writer = stream.getWriter();
writer.write('chunk1')
  .then(() => writer.write('chunk2'))
  .then(() => writer.write('chunk3'))
  .then(() => writer.close())
  .then(() => console.log('order:' + results.join(',')));
```
```bash
./zig-out/bin/nano eval "$(cat /tmp/test_async_sink.js)"
```
Expected: `order:chunk1,chunk2,chunk3`

Test backpressure (ready resolves after drain):
```javascript
const stream = new WritableStream({
  write(chunk) {
    return new Promise(resolve => setTimeout(resolve, 50));
  }
}, { highWaterMark: 1 });
const writer = stream.getWriter();
writer.write('a');
const readyBefore = writer.ready;
writer.write('b'); // queues, triggers backpressure
writer.ready.then(() => console.log('ready:resolved'));
```
Expected: `ready:resolved` prints after the first write drains.
  </verify>
  <done>Build succeeds. Async sink write() returns Promise that resolves only after sink drains. Sequential writes complete in order. Sync sinks continue to resolve immediately (regression test: existing tests pass).</done>
</task>

</tasks>

<verification>
After task completes:
1. `zig build` succeeds
2. Async sink: `writer.write('chunk1').then(() => writer.write('chunk2'))` — second write waits for first sink to drain
3. Order preserved: chunks arrive at sink in write() call order
4. Sync sink regression: `new WritableStream({ write(c){} })` still resolves immediately
5. Backpressure: `writer.ready` is pending while queue above highWaterMark, resolves when queue drains
</verification>

<success_criteria>
- ASYNC-03: WritableStream with async sink (Promise-returning write) signals backpressure correctly
- write() returns a Promise that resolves when the sink's Promise resolves (not immediately)
- Multiple sequential writes execute in order with async sink
- Sync sinks unaffected — write() still resolves immediately for non-Promise return values
</success_criteria>

<output>
After completion, create `.planning/phases/v1.3-01-async-foundation/v1.3-01-03-SUMMARY.md` with:
- Implementation approach chosen (JS promise chaining vs polling vs __writableSinkContinue global)
- Files changed
- How `__writableSinkContinue` or equivalent is wired up
- Any V8 API used (isPromise, microtask checkpoint)
- Verification results (async sink test output, order proof)
</output>
