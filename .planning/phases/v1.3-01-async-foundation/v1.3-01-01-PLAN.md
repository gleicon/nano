---
phase: v1.3-01
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/blob.zig
  - src/api/encoding.zig
  - src/api/console.zig
autonomous: true

must_haves:
  truths:
    - "new Blob(['x'.repeat(1024*1024)]) stores 1MB without truncation"
    - "blob.text() on a 1MB Blob resolves to the full 1MB string"
    - "blob.arrayBuffer() on a 1MB Blob resolves to an ArrayBuffer with 1MB bytes"
    - "atob(btoa(largeStr)) round-trips a 50KB base64 string correctly"
    - "console.log of a 10KB string prints the full value without truncation"
  artifacts:
    - path: "src/api/blob.zig"
      provides: "Blob constructor and text/arrayBuffer/slice with heap fallback"
      contains: "alloc(u8, total_size)"
    - path: "src/api/encoding.zig"
      provides: "atob/btoa with heap fallback for >8KB inputs"
      contains: "utf8LengthV2"
    - path: "src/api/console.zig"
      provides: "writeValue using heap for strings >4096 bytes"
      contains: "page_allocator.alloc"
  key_links:
    - from: "src/api/blob.zig blobConstructor"
      to: "heap-allocated data_buf"
      via: "std.heap.page_allocator.alloc(u8, total_size)"
      pattern: "alloc\\(u8, total_size\\)"
    - from: "src/api/encoding.zig atobCallback"
      to: "heap input buffer"
      via: "str.utf8LengthV2(isolate) length check before alloc"
      pattern: "utf8LengthV2"
---

<objective>
Replace all hardcoded stack buffers in blob, encoding, and console APIs with stack+heap fallback pattern. Large inputs (>stack size) allocate from heap; small inputs use the fast stack path. Eliminates BUF-01 through BUF-05 truncation bugs.

Purpose: Blob data >64KB, base64 strings >8KB, and console output >4KB silently truncate today. This plan fixes all five buffer requirements without introducing new dependencies.
Output: Modified blob.zig, encoding.zig, console.zig with heap fallback on all variable-size string/binary operations.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v1.3-01-async-foundation/v1.3-01-RESEARCH.md
@src/api/blob.zig
@src/api/encoding.zig
@src/api/console.zig
@src/js.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Heap fallback in blob.zig (BUF-01, BUF-02)</name>
  <files>src/api/blob.zig</files>
  <action>
Replace fixed-size stack buffers in blob.zig with heap fallback. Apply to every function that reads user-supplied data into a fixed buffer.

The allocator to use is `std.heap.page_allocator` — already used in blob.zig as `blob_allocator` at the top.

Functions to change (the pattern is identical in each):

**blobConstructor** (around line 145, `var data_buf: [65536]u8 = undefined`):
- First pass already computes `total_size` (sum of all parts). Use this.
- Replace `var data_buf: [65536]u8 = undefined` with heap allocation:
  ```zig
  const data_buf = blob_allocator.alloc(u8, total_size + 1) catch {
      js.throw(ctx.isolate, "Blob: out of memory");
      return;
  };
  defer blob_allocator.free(data_buf);
  ```
- Remove the `if (encoded_len <= 65536)` guard. Compute `encoded_len`, heap-allocate the encoded buffer too:
  ```zig
  const encoded_buf = blob_allocator.alloc(u8, encoded_len) catch {
      js.throw(ctx.isolate, "Blob: out of memory");
      return;
  };
  defer blob_allocator.free(encoded_buf);
  _ = base64_encoder.Encoder.encode(encoded_buf[0..encoded_len], data_buf[0..offset]);
  _ = js.setProp(ctx.this, ctx.context, ctx.isolate, "_data", js.string(ctx.isolate, encoded_buf[0..encoded_len]));
  _ = js.setProp(ctx.this, ctx.context, ctx.isolate, "_size", js.number(ctx.isolate, offset));
  ```

**blobText** (around line 229, `var data_buf: [65536]u8 = undefined`):
- Get the encoded data length first: `const encoded_len_hint = data_str.lenUtf8(ctx.isolate);`
- Heap allocate: `const data_buf = blob_allocator.alloc(u8, encoded_len_hint + 1) catch { return js.retResolvedPromise(ctx, empty); };`
- Use `js.readString(ctx.isolate, data_str, data_buf)` to fill it.
- Replace the stack `decoded_buf: [65536]u8` with heap-allocated `decoded_buf` sized to `decoded_len`.
- Replace `decoded_buf[0..decoded_len]` with `decoded_buf`.

**blobArrayBuffer** (around line 263, `var data_buf: [65536]u8 = undefined`):
- Same pattern: get `data_str.lenUtf8()`, heap-allocate `data_buf`, heap-allocate `decoded_buf` for `decoded_len`.
- Remove the inner `var decoded_buf: [65536]u8`.

**blobSlice** (around lines 370, 391 — two fixed buffers):
- `var encoded_buf: [65536]u8`: replace with `blob_allocator.alloc(u8, data_str.lenUtf8(ctx.isolate) + 1)`.
- `var decoded_buf: [65536]u8`: replace with `blob_allocator.alloc(u8, decoded_len)`.
- `var re_encoded_buf: [65536]u8`: replace with `blob_allocator.alloc(u8, re_encoded_len)`.
- Remove the `if (re_encoded_len <= 65536)` guard.

**fileConstructor** (around line 439, `var data_buf: [65536]u8 = undefined`):
- Same as blobConstructor: heap-allocate `data_buf` based on `total_size`, heap-allocate `encoded_buf`.

**createBlob** helper (around line 70): already uses `blob_allocator.alloc` for `encoded` — no change needed.

Important: Keep all `defer blob_allocator.free(...)` calls immediately after each alloc. Each allocation is request-scoped (freed before the callback returns).
  </action>
  <verify>
Build: `rm -rf /Users/gleicon/code/zig/nano/.zig-cache && zig build 2>&1 | head -50`

Run test:
```
echo 'const big = "A".repeat(1024*1024); const b = new Blob([big]); b.text().then(t => console.log("blob_size:" + t.length));' > /tmp/test_blob.js
./zig-out/bin/nano eval "$(cat /tmp/test_blob.js)"
```
Expected: prints `blob_size:1048576`
  </verify>
  <done>Build succeeds with no errors. eval of 1MB Blob prints `blob_size:1048576` (not 65536 or less).</done>
</task>

<task type="auto">
  <name>Task 2: Heap fallback in encoding.zig and console.zig (BUF-04, BUF-05)</name>
  <files>src/api/encoding.zig, src/api/console.zig</files>
  <action>
**encoding.zig — atob and btoa:**

Apply heap fallback pattern using `std.heap.page_allocator` (add `const page_allocator = std.heap.page_allocator;` at top of file or use `std.heap.page_allocator` inline).

**atobCallback:**
- After getting `str`, get length: `const str_len = str.utf8LengthV2(ctx.isolate);`
  - NOTE: Check V8 binding — if `utf8LengthV2` unavailable, use `str.lenUtf8(ctx.isolate)` (already used in blob.zig line 103)
- Stack fast path threshold: 8192 bytes
- If `str_len <= 8192`: use existing `var input_buf: [8192]u8 = undefined; const input = js.readString(ctx.isolate, str, &input_buf);`
- Else: `const heap_buf = std.heap.page_allocator.alloc(u8, str_len) catch { js.throw(ctx.isolate, "atob: out of memory"); return; }; defer std.heap.page_allocator.free(heap_buf); const input = js.readString(ctx.isolate, str, heap_buf);`
- For output: after computing `decoded_size`, apply same stack/heap split with threshold 8192:
  - Stack: existing `var output_buf: [8192]u8 = undefined`
  - Heap: `const heap_out = std.heap.page_allocator.alloc(u8, decoded_size) catch { ...; return; }; defer std.heap.page_allocator.free(heap_out);`
  - Remove the `if (decoded_size > output_buf.len) { js.throw(...); return; }` hard error — replace with the heap path.

**btoaCallback:**
- Same pattern: get `str_len = str.lenUtf8(ctx.isolate)`
- Stack threshold 8192; heap for larger inputs
- Output: `encoded_size = std.base64.standard.Encoder.calcSize(str_len)`. If > 16384, heap-allocate output buffer. Remove fixed `var output_buf: [16384]u8`.
  - Stack: existing `var output_buf: [16384]u8` if `encoded_size <= 16384`
  - Heap: `const heap_out = std.heap.page_allocator.alloc(u8, encoded_size) catch { ...; return; }; defer std.heap.page_allocator.free(heap_out);`

**console.zig — writeValue:**

The `writeValue` function has `var buf: [4096]u8 = undefined` in 4 places (string, number, object fallback, else branch).

For the string case (most important — BUF-05):
```zig
if (value.isString()) {
    const str = value.toString(context) catch return;
    const str_len = str.lenUtf8(isolate);
    if (str_len <= 4096) {
        var buf: [4096]u8 = undefined;
        file.writeAll(js.readString(isolate, str, &buf)) catch {};
    } else {
        const heap_buf = std.heap.page_allocator.alloc(u8, str_len) catch return;
        defer std.heap.page_allocator.free(heap_buf);
        file.writeAll(js.readString(isolate, str, heap_buf)) catch {};
    }
}
```

For the object JSON stringify result (also a string — apply same heap check):
```zig
const result_str = result.toString(context) catch { ... };
const rlen = result_str.lenUtf8(isolate);
if (rlen <= 4096) {
    var buf: [4096]u8 = undefined;
    file.writeAll(js.readString(isolate, result_str, &buf)) catch {};
} else {
    const heap_buf = std.heap.page_allocator.alloc(u8, rlen) catch return;
    defer std.heap.page_allocator.free(heap_buf);
    file.writeAll(js.readString(isolate, result_str, heap_buf)) catch {};
}
```

Numbers and booleans are always small — keep fixed `[64]u8` for numbers.
  </action>
  <verify>
Build: `zig build 2>&1 | head -30`

Test atob/btoa:
```
./zig-out/bin/nano eval "const s = 'A'.repeat(50000); const enc = btoa(s); const dec = atob(enc); console.log('match:' + (dec === s)); console.log('len:' + dec.length);"
```
Expected: `match:true` and `len:50000`

Test console.log:
```
./zig-out/bin/nano eval "console.log('X'.repeat(10000));" | wc -c
```
Expected: prints 10001 characters (10000 Xs + newline).
  </verify>
  <done>Build succeeds. atob/btoa round-trips 50KB string correctly (match:true, len:50000). console.log of 10KB string outputs full 10001 bytes.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `zig build` succeeds with no errors
2. Blob 1MB round-trip: `new Blob(['x'.repeat(1024*1024)]).text()` resolves to string of length 1048576
3. atob/btoa 50KB: `atob(btoa('A'.repeat(50000))).length === 50000`
4. console.log 10KB: output is exactly 10001 bytes (10000 chars + newline)
5. Existing tests unaffected: `zig build test` passes
</verification>

<success_criteria>
- BUF-01: Blob constructor stores >64KB data (tested with 1MB)
- BUF-02: Blob.text() and Blob.arrayBuffer() return full >64KB data
- BUF-03: fetch() body remains unchanged (addressed in plan-02)
- BUF-04: atob()/btoa() handle >8KB input correctly
- BUF-05: console.log prints strings >4KB without truncation
- No regressions: existing small-input behavior unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/v1.3-01-async-foundation/v1.3-01-01-SUMMARY.md` with:
- What was implemented
- Files changed
- Key patterns used (heap fallback, length check before alloc)
- Any V8 API notes (e.g., which string length function is available)
- Verification results
</output>
