---
phase: v1.3-01-async-foundation
verified: 2026-02-17T22:48:17Z
status: passed
score: 5/5 must-haves verified
re_verification: false
---

# Phase v1.3-01: Async Foundation Verification Report

**Phase Goal:** Buffers never truncate on large inputs, and fetch() runs non-blocking with proper Promise resolution and backpressure-aware WritableStream
**Verified:** 2026-02-17T22:48:17Z
**Status:** passed
**Re-verification:** No — initial verification

---

## Goal Achievement

### Observable Truths (Success Criteria)

| # | Truth | Status | Evidence |
|---|-------|--------|----------|
| 1 | A handler creating a Blob with 1MB data returns the full 1MB from Blob.text() — no truncation at 64KB | VERIFIED | `blobConstructor` heap-allocates `data_buf` via `blob_allocator.alloc(u8, total_size + 1)` (blob.zig:146). `blobText` heap-allocates decode buffer via `blob_allocator.alloc(u8, decoded_len)` (blob.zig:246). No 65536 cap exists in any Blob path. |
| 2 | A fetch() call to a slow external endpoint returns a Promise immediately; other setTimeout callbacks fire while the fetch is in-flight | VERIFIED | `fetchCallback` (fetch.zig:295) creates Promise before spawning thread (line 306), calls `std.Thread.spawn(.{}, fetchWorker, .{op})` (line 494), returns unresolved Promise (line 505). Event loop in app.zig:551-568 calls `timers.executePendingTimers` + `fetch_api.resolveCompletedFetches` each iteration. |
| 3 | Two concurrent fetch() calls to different hosts resolve independently without one blocking the other | VERIFIED | Each `fetchCallback` invocation spawns a separate detached thread (fetch.zig:494-502). `pending_fetch_count` atomic counter tracks both. `completed_fetches` mutex-protected list accumulates both results independently. `resolveCompletedFetches` drains all at once (fetch.zig:83-113). |
| 4 | A WritableStream with an async sink function returns a Promise that resolves when the sink drains, and signals backpressure correctly | VERIFIED | `processWriteQueue` calls `wr.isPromise()` on write_fn return value (writable_stream.zig:621). Async path stores sink promise on stream, registers via `registerPendingAsyncStream`, returns without resolving write promise (lines 627-635). `checkAsyncSinkCompletion` polls V8 Promise state and resolves write promise on fulfillment (lines 711-811). `processPendingAsyncSinks` called from app.zig:560. |
| 5 | atob()/btoa() with a 50KB base64 string round-trips correctly; console.log of a 10KB string prints the full value | VERIFIED | `atobCallback` uses stack/heap fallback: `lenUtf8` check, stack 8192 else `page_allocator.alloc` (encoding.zig:40-50). `btoaCallback` same pattern with 8192/16384 thresholds (lines 92-117). `writeValue` in console.zig:54-61 uses heap for str_len > 4096. |

**Score: 5/5 truths verified**

---

### Required Artifacts

| Artifact | Expected | Status | Details |
|----------|----------|--------|---------|
| `src/api/blob.zig` | Blob constructor and text/arrayBuffer/slice with heap fallback | VERIFIED | `alloc(u8, total_size + 1)` at line 146; `alloc(u8, decoded_len)` in blobText, blobArrayBuffer, blobSlice, fileConstructor. No 65536 stack buffers remain in data paths. |
| `src/api/encoding.zig` | atob/btoa with heap fallback for >8KB inputs | VERIFIED | `lenUtf8` used for length check; `page_allocator.alloc` for both input (>8192) and output (>8192/16384) buffers in both functions. |
| `src/api/console.zig` | writeValue using heap for strings >4096 bytes | VERIFIED | All four value branches (string, object stringify, stringify fallback, else) use stack/heap split. String path at lines 54-61. |
| `src/api/fetch.zig` | Non-blocking fetchCallback using thread pool + promise resolver | VERIFIED | `FetchOperation` struct at line 23. `storeResolver`/`takeResolver` resolver registry at lines 50-80. `fetchWorker` at line 116. `fetchCallback` async path at line 428-505. `resolveCompletedFetches` at line 83. |
| `src/runtime/event_loop.zig` | FetchOperation queue and async resolution | VERIFIED | `CompletedFetch` struct at lines 5-18. `pending_fetch_count`, `completed_fetches`, `fetch_mutex` fields at lines 171-173. `incrementPendingFetch`, `addCompletedFetch`, `drainCompletedFetches` methods at lines 260-278. `hasPendingWork` includes fetch count at line 252. |
| `src/api/writable_stream.zig` | processWriteQueue with async sink detection | VERIFIED | `isPromise()` check at line 621. `registerPendingAsyncStream` at line 13. `processPendingAsyncSinks` at line 19 (exported). `checkAsyncSinkCompletion` at line 711. |

---

### Key Link Verification

| From | To | Via | Status | Details |
|------|----|-----|--------|---------|
| `blob.zig blobConstructor` | heap-allocated data_buf | `blob_allocator.alloc(u8, total_size + 1)` | WIRED | Line 146 confirms heap alloc based on `total_size` computed in first pass (lines 98-113). |
| `encoding.zig atobCallback` | heap input buffer | `lenUtf8` length check before alloc | WIRED | Lines 40-50: `str_len = str.lenUtf8(ctx.isolate)` → conditional `page_allocator.alloc`. Note: plan specified `utf8LengthV2` but `lenUtf8` was used — functionally identical per research notes. |
| `fetch.zig fetchCallback` | FetchOperation allocated and queued | thread spawn + `el.incrementPendingFetch()` | WIRED | Lines 491-502: `incrementPendingFetch()` called before `Thread.spawn`. Thread is detached. `FetchOperation` heap-allocated at line 439. |
| `event_loop.zig processEventLoop` | FetchOperation resolution | `completed_fetches` + `addCompletedFetch` | WIRED | `fetchWorker` calls `el.addCompletedFetch` (lines 124-131 and 140-148). Main loop drains via `drainCompletedFetches` (app.zig:557). |
| `writable_stream.zig writerWrite` | processWriteQueue | `write()` adds to queue, processWriteQueue called | WIRED | `writerWrite` calls `processWriteQueue(ctx.isolate, ctx.context, stream)` at line 518. |
| `writable_stream.zig processWriteQueue` | sink return Promise | `wr.isPromise()` check at line 621 | WIRED | `write_result.isPromise()` branches to async path; `registerPendingAsyncStream` at line 632; `processPendingAsyncSinks` called from app.zig:560. |

---

### Requirements Coverage

| Requirement | Status | Notes |
|-------------|--------|-------|
| BUF-01 (Blob constructor >64KB) | SATISFIED | Heap alloc based on `total_size` |
| BUF-02 (Blob.text() / arrayBuffer() >64KB) | SATISFIED | Both methods heap-allocate decode buffers |
| BUF-03 (fetch() request body >64KB) | SATISFIED | Stack/heap split in fetchCallback at lines 318-425 |
| BUF-04 (atob/btoa >8KB) | SATISFIED | Stack/heap fallback in both encoding functions |
| BUF-05 (console.log >4KB) | SATISFIED | All writeValue branches use heap for >4096 |
| ASYNC-01 (fetch returns Promise immediately, timers fire during fetch) | SATISFIED | Thread-pool fetch + event loop integration in app.zig |
| ASYNC-02 (Two concurrent fetches resolve independently) | SATISFIED | Each fetch spawns independent detached thread with unique resolver_id |
| ASYNC-03 (WritableStream async sink backpressure) | SATISFIED | isPromise() detection, polling via processPendingAsyncSinks |

---

### Anti-Patterns Found

| File | Line | Pattern | Severity | Impact |
|------|------|---------|----------|--------|
| `src/api/fetch.zig` | 860 | `var body_buf: [65536]u8 = undefined` in `responseBody` | Warning | Truncates response body to 64KB when creating a ReadableStream from `response.body`. Does NOT affect `response.text()` or `response.json()`. Not in scope of any Success Criterion. |

**Assessment:** The remaining 64KB buffer at fetch.zig:860 is in the `responseBody` function's ReadableStream creation path. This was not covered by BUF-03 (which targets request bodies, not response streaming). The success criteria do not test `response.body` as a stream with large payloads. This is a warning for a future phase, not a blocker for this phase's goals.

---

### Human Verification Required

The following items cannot be fully verified programmatically and require a running server:

#### 1. Non-blocking fetch with timer interleaving

**Test:** Start NANO server with an app that does:
```javascript
let timerFired = false;
setTimeout(() => { timerFired = true; console.log('timer:fired'); }, 10);
fetch('https://httpbin.org/delay/0.5')
  .then(r => r.text())
  .then(() => console.log('fetch:done:timerFired=' + timerFired));
```
**Expected:** `timer:fired` appears before `fetch:done:timerFired=true`
**Why human:** Requires live network access to a slow external endpoint and actual wall-clock timing measurement.

#### 2. Two concurrent fetch() calls

**Test:** Handler that calls `fetch(url1)` and `fetch(url2)` concurrently via `Promise.all`, both to different external hosts.
**Expected:** Both resolve within a small time window — not sequentially (where second waits for first).
**Why human:** Requires timing measurement and live network.

#### 3. WritableStream async sink order preservation

**Test:** Run the async sink test:
```javascript
const results = [];
const stream = new WritableStream({
  write(chunk) {
    return new Promise(resolve => setTimeout(() => { results.push(chunk); resolve(); }, 10));
  }
});
const writer = stream.getWriter();
await writer.write('a'); await writer.write('b'); await writer.write('c');
console.log('order:' + results.join(','));
```
**Expected:** `order:a,b,c`
**Why human:** Requires running nano eval with an event loop active and setTimeout support.

---

### Gaps Summary

No blocking gaps found. All 5 success criteria are verified at the code level:

- Blob/encoding/console heap fallback: substantively implemented with correct patterns (alloc based on runtime-computed size, not fixed thresholds that could still truncate).
- fetch() async: full thread-pool architecture wired from fetchCallback through EventLoop to app.zig promise wait loop.
- WritableStream: async sink detection via `isPromise()` with polling-based completion via `processPendingAsyncSinks`.

The remaining 64KB buffer in `responseBody` (stream creation path) is out of scope for this phase's requirements and is logged as a warning for future cleanup.

Commits confirmed present:
- `fe910c3` — heap buffer fallback (plan 01)
- `5e03570` — EventLoop fetch queue (plan 02, task 1)
- `2676539` — async fetch + WritableStream (plan 02+03)

---

_Verified: 2026-02-17T22:48:17Z_
_Verifier: Claude (gsd-verifier)_
