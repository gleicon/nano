# Plan v1.3-01-02 Summary

## Status: COMPLETE

## What was done

Made fetch() non-blocking in server mode using std.Thread worker pool with Promise-based resolution.

### Architecture
- **Thread pool approach** chosen over xev socket state machine (simpler, avoids unvalidated xev.Tcp API)
- Worker threads perform blocking HTTP I/O, post CompletedFetch results to EventLoop via mutex-protected queue
- Persistent(PromiseResolver) keeps V8 handles alive across event loop ticks
- Resolver registry maps unique IDs to persistent resolvers (thread-safe with mutex)

### src/runtime/event_loop.zig (Task 1 — committed separately as `5e03570`)
- `CompletedFetch` struct for thread-to-main result transfer
- `pending_fetch_count` atomic counter for hasPendingWork()
- `completed_fetches` list with mutex protection
- `incrementPendingFetch`, `addCompletedFetch`, `drainCompletedFetches` methods

### src/api/fetch.zig (Task 2)
- `FetchOperation` struct (url, method, body, resolver_id, event_loop pointer)
- `storeResolver` / `takeResolver` — mutex-protected resolver registry
- `fetchWorker` — background thread: doFetch() + post CompletedFetch
- `resolveCompletedFetches` — main thread: drain queue, castToPromiseResolver, resolve/reject
- `setEventLoop` — set once at server startup
- `fetchCallback` rewritten: async path spawns thread, sync fallback for eval/repl mode
- BUF-03: heap-allocate request body when >64KB (stack+heap fallback pattern)

### build.zig
- Added `fetch_module.addImport("event_loop", event_loop_module)`
- Added `server_module.addImport("fetch", fetch_module)`

### src/server/http.zig
- Import `fetch_api = @import("fetch")`
- Call `fetch_api.setEventLoop` alongside `timers.setEventLoop` at startup
- `processEventLoop`: drain completed fetches after timer callbacks

### src/server/app.zig
- Promise wait loop: call `timers.executePendingTimers` + `fetch_api.resolveCompletedFetches`
- Added 1ms sleep per iteration to yield CPU to worker threads

## Test Results

All success criteria verified:
- Async fetch: `timer_fired=true` during in-flight fetch (timer interleaving works)
- Concurrent fetches: both resolve independently with status 200
- fetch().json(): parses JSON correctly
- fetch error handling: invalid host correctly rejects with "ConnectionFailed"
- Sequential fetches: 3 sequential fetches all return 200
- Mixed async: timer + fetch + Promise.resolve all work in same handler
- Sync fallback: `nano eval` fetch still works synchronously
- SSRF: localhost/private IPs correctly blocked

## Commits
- `5e03570` — feat(v1.3-01-02): add fetch operation queue to EventLoop
- `2676539` — feat(v1.3-01): async fetch with thread pool and WritableStream async sink detection

## Files Changed
- `src/runtime/event_loop.zig` — 52 lines changed (CompletedFetch, fetch queue)
- `src/api/fetch.zig` — 290 lines changed (async infrastructure + fetchCallback rewrite)
- `src/server/http.zig` — 21 lines changed (wiring)
- `src/server/app.zig` — 11 lines changed (wait loop integration)
- `build.zig` — 4 lines changed (module imports)
