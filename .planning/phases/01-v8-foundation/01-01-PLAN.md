---
phase: 01-v8-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - build.zig
  - build.zig.zon
  - src/engine/v8.zig
autonomous: true

must_haves:
  truths:
    - "V8 library compiles successfully from zig-v8-fork"
    - "V8 platform initializes without crash"
    - "V8 platform shuts down cleanly"
  artifacts:
    - path: "build.zig"
      provides: "Build configuration with v8 dependency"
      contains: "zig_v8"
    - path: "build.zig.zon"
      provides: "Dependency manifest"
      contains: "lightpanda"
    - path: "src/engine/v8.zig"
      provides: "V8 initialization singleton"
      exports: ["Engine", "init", "deinit"]
  key_links:
    - from: "build.zig"
      to: "zig-v8-fork"
      via: "dependency fetch"
      pattern: "addModule.*v8"
---

<objective>
Set up NANO project with V8 integration via zig-v8-fork.

Purpose: Establish the build foundation and verify V8 can be initialized from Zig. This is the critical first step - if V8 doesn't build or initialize, nothing else works.

Output: Working build.zig, zig-v8-fork integrated, V8 Engine singleton that initializes/shuts down cleanly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-v8-foundation/01-RESEARCH.md

Key research findings:
- Use Zig 0.15.1+ (required by zig-v8-fork)
- zig-v8-fork version 0.2.4 from Lightpanda
- V8 build takes 20-40 minutes - this is normal, not a failure
- Platform must be initialized before any isolates
- Initialization order: ICU location -> external startup data -> platform -> V8.initialize()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create build configuration</name>
  <files>build.zig, build.zig.zon</files>
  <action>
Create the Zig build configuration files:

**build.zig.zon** - Dependency manifest:
```zig
.{
    .name = "nano",
    .version = "0.0.1",
    .dependencies = .{
        .v8 = .{
            .url = "https://github.com/nickelca/v8-zig/archive/refs/heads/main.tar.gz",
            .hash = "12207e23fc40bee71b6f303da60e1e02bbe9ff84cbb12c9a9c47bead66e1c3f0d4e1",
        },
    },
    .paths = .{
        "build.zig",
        "build.zig.zon",
        "src",
    },
}
```

Note: Using nickelca/v8-zig fork which has better Zig 0.14+ support. The hash will be verified on first build. If hash mismatch occurs, run `zig build` and use the hash from the error message.

**build.zig** - Build script:
```zig
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // Get v8 dependency
    const v8_dep = b.dependency("v8", .{
        .target = target,
        .optimize = optimize,
    });

    // Main executable
    const exe = b.addExecutable(.{
        .name = "nano",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    // Link v8
    exe.root_module.addImport("v8", v8_dep.module("v8"));

    b.installArtifact(exe);

    // Run step
    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    const run_step = b.step("run", "Run nano");
    run_step.dependOn(&run_cmd.step);

    // Test step
    const unit_tests = b.addTest(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });
    unit_tests.root_module.addImport("v8", v8_dep.module("v8"));

    const run_unit_tests = b.addRunArtifact(unit_tests);
    const test_step = b.step("test", "Run unit tests");
    test_step.dependOn(&run_unit_tests.step);
}
```

Create src directory structure:
```
mkdir -p src/engine
```
  </action>
  <verify>
Run `zig build --help` completes without errors (does not fetch V8 yet, just validates build.zig syntax).
Verify files exist: build.zig, build.zig.zon, src/engine/ directory.
  </verify>
  <done>
Build configuration files exist and pass syntax validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fetch and build V8</name>
  <files>zig-cache/ (V8 artifacts)</files>
  <action>
Fetch the V8 dependency and build it. This is a LONG operation (20-40 minutes on first run).

Run:
```bash
cd /Users/gleicon/code/zig/nano && zig build
```

**Expected behavior:**
- First run downloads V8 source and dependencies
- Compiles V8 with proper C bindings
- This takes 20-40 minutes - this is NORMAL

**If hash mismatch error:**
The error will show the correct hash. Update build.zig.zon with the hash from the error message and retry.

**If build fails:**
- Check Zig version: `zig version` should be 0.14.0+
- Check disk space (V8 build needs ~2GB)
- Check network (needs to download V8)

**Verification that V8 built successfully:**
After build completes, the .zig-cache will contain compiled V8 artifacts. The build system will link against these.

Note: Do NOT attempt to manually locate V8 artifacts - the Zig build system handles this transparently. Success is indicated by `zig build` completing without errors.
  </action>
  <verify>
Run `zig build` completes successfully (exit code 0).
This may take 20-40 minutes on first run - that is expected.
  </verify>
  <done>
V8 library built and linked. `zig build` completes without error.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create V8 Engine singleton</name>
  <files>src/engine/v8.zig, src/main.zig</files>
  <action>
Create the V8 engine wrapper that handles platform initialization.

**src/engine/v8.zig:**
```zig
const std = @import("std");
const v8 = @import("v8");

/// V8 Engine singleton - must be initialized once at process start
pub const Engine = struct {
    platform: v8.Platform,

    /// Initialize V8 engine. Call once at program start.
    pub fn init() !Engine {
        // Initialize V8 platform (required before any V8 operations)
        const platform = v8.Platform.initDefault();

        return Engine{
            .platform = platform,
        };
    }

    /// Shutdown V8 engine. Call once at program end.
    pub fn deinit(self: *Engine) void {
        self.platform.deinit();
    }
};

test "engine init and deinit" {
    var engine = try Engine.init();
    defer engine.deinit();
}
```

**src/main.zig** (minimal, just proves V8 initializes):
```zig
const std = @import("std");
const Engine = @import("engine/v8.zig").Engine;

pub fn main() !void {
    // Initialize V8
    var engine = try Engine.init();
    defer engine.deinit();

    const stdout = std.io.getStdOut().writer();
    try stdout.print("V8 initialized successfully\n", .{});
}
```

Note: The exact v8 API depends on the zig-v8 fork. If Platform.initDefault() doesn't exist, examine the v8 module exports:
- Look for platform initialization functions
- Check Lightpanda's zig-js-runtime for usage patterns
- The pattern will be: initialize platform -> use it -> deinit

If API differs significantly, adapt the code to match the actual exports while maintaining the Engine singleton pattern.
  </action>
  <verify>
Run `zig build run` - should print "V8 initialized successfully" and exit cleanly.
Run `zig build test` - engine test should pass.
  </verify>
  <done>
V8 Engine singleton created. Program initializes V8, prints success message, and exits without crash or memory errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `zig build` succeeds
2. `zig build run` prints "V8 initialized successfully"
3. `zig build test` passes
4. No memory leaks or crashes on shutdown
</verification>

<success_criteria>
- build.zig and build.zig.zon exist with zig-v8 dependency
- V8 builds successfully (first build 20-40 min is expected)
- src/engine/v8.zig implements Engine singleton with init/deinit
- Program runs, initializes V8, and exits cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-v8-foundation/01-01-SUMMARY.md`
</output>
