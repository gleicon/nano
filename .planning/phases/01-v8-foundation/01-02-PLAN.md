---
phase: 01-v8-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/engine/script.zig
  - src/engine/error.zig
  - src/engine/v8.zig
autonomous: true

must_haves:
  truths:
    - "JavaScript code can be compiled and executed"
    - "Script results are returned as strings"
    - "Syntax errors produce meaningful error messages with line numbers"
    - "Runtime errors are captured and reported"
  artifacts:
    - path: "src/engine/script.zig"
      provides: "Script compilation and execution"
      exports: ["runScript", "ScriptResult"]
    - path: "src/engine/error.zig"
      provides: "Error extraction from V8 TryCatch"
      exports: ["ScriptError", "extractError"]
  key_links:
    - from: "src/engine/script.zig"
      to: "src/engine/v8.zig"
      via: "imports Engine"
      pattern: "Engine"
    - from: "src/engine/script.zig"
      to: "src/engine/error.zig"
      via: "imports error handling"
      pattern: "extractError"
---

<objective>
Implement JavaScript script execution with proper error handling.

Purpose: This is the core functionality - taking JavaScript source code, compiling it, running it, and returning results or meaningful error messages. This directly satisfies two of the three Phase 1 success criteria.

Output: Script execution module that can evaluate JS and return results, error module that extracts meaningful error messages from V8.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-v8-foundation/01-RESEARCH.md

Reference prior plan output:
@.planning/phases/01-v8-foundation/01-01-SUMMARY.md (for actual v8 API learned)

Key patterns from research:
- Isolate.CreateParams needs ArrayBuffer.Allocator
- HandleScope required for all V8 handle operations
- Context required for script execution
- TryCatch wraps operations that may throw JS errors
- Use Utf8Value to convert V8 strings to Zig strings
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error handling module</name>
  <files>src/engine/error.zig</files>
  <action>
Create the error handling module that extracts meaningful error information from V8.

**src/engine/error.zig:**
```zig
const std = @import("std");
const v8 = @import("v8");

/// Represents an error from JavaScript execution
pub const ScriptError = struct {
    message: []const u8,
    line: ?u32 = null,
    column: ?u32 = null,
    source_line: ?[]const u8 = null,

    pub fn format(self: ScriptError, allocator: std.mem.Allocator) ![]const u8 {
        if (self.line) |line| {
            if (self.column) |col| {
                return std.fmt.allocPrint(allocator, "Error at line {d}, column {d}: {s}", .{ line, col, self.message });
            }
            return std.fmt.allocPrint(allocator, "Error at line {d}: {s}", .{ line, self.message });
        }
        return std.fmt.allocPrint(allocator, "Error: {s}", .{self.message});
    }
};

/// Extract error information from a V8 TryCatch
/// Returns ScriptError with message and location info
pub fn extractError(
    isolate: v8.Isolate,
    try_catch: v8.TryCatch,
    allocator: std.mem.Allocator,
) !ScriptError {
    // Get the exception message
    const message = try_catch.getMessage() orelse {
        return ScriptError{ .message = "Unknown error" };
    };

    // Get the message string
    const msg_str = message.get();
    const msg_utf8 = msg_str.toUtf8(isolate);
    defer msg_utf8.deinit();

    const msg_slice = try allocator.dupe(u8, msg_utf8.slice());

    // Try to get line number
    const line: ?u32 = blk: {
        const context = isolate.getCurrentContext();
        const line_num = message.getLineNumber(context);
        break :blk if (line_num > 0) @intCast(line_num) else null;
    };

    // Try to get column
    const column: ?u32 = blk: {
        const col = message.getStartColumn();
        break :blk if (col >= 0) @intCast(col) else null;
    };

    return ScriptError{
        .message = msg_slice,
        .line = line,
        .column = column,
    };
}
```

Note: The exact V8 API for TryCatch and Message may differ. Consult the actual v8 module exports discovered in Plan 01. Key requirements:
- Extract error message text
- Extract line number if available
- Convert V8 strings to Zig strings

If API differs, adapt while maintaining the ScriptError struct interface.
  </action>
  <verify>
File exists and compiles: `zig build` succeeds.
  </verify>
  <done>
Error module created with ScriptError struct and extractError function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create script execution module</name>
  <files>src/engine/script.zig</files>
  <action>
Create the script execution module that compiles and runs JavaScript.

**src/engine/script.zig:**
```zig
const std = @import("std");
const v8 = @import("v8");
const error_mod = @import("error.zig");

pub const ScriptError = error_mod.ScriptError;

/// Result of script execution
pub const ScriptResult = union(enum) {
    ok: []const u8,
    err: ScriptError,
};

/// Execute JavaScript code and return result
/// Caller owns returned memory (allocated from provided allocator)
pub fn runScript(
    source: []const u8,
    allocator: std.mem.Allocator,
) ScriptResult {
    // Create isolate with ArrayBuffer allocator
    var isolate = v8.Isolate.create(.{
        .array_buffer_allocator = v8.ArrayBuffer.Allocator.newDefaultAllocator(),
    });
    defer isolate.destroy();

    // Enter isolate scope
    var isolate_scope = isolate.enter();
    defer isolate_scope.exit();

    // Create handle scope for local handles
    var handle_scope = v8.HandleScope.init(isolate);
    defer handle_scope.deinit();

    // Create and enter context
    var context = v8.Context.create(isolate, null, null);
    var context_scope = context.enter();
    defer context_scope.exit();

    // Set up TryCatch for error handling
    var try_catch = v8.TryCatch.init(isolate);
    defer try_catch.deinit();

    // Create source string
    const source_str = v8.String.createFromSlice(isolate, source) orelse {
        return .{ .err = .{ .message = "Failed to create source string" } };
    };

    // Compile script
    const script = v8.Script.compile(context, source_str, null) orelse {
        if (try_catch.hasCaught()) {
            const err = error_mod.extractError(isolate, try_catch, allocator) catch {
                return .{ .err = .{ .message = "Error during compilation" } };
            };
            return .{ .err = err };
        }
        return .{ .err = .{ .message = "Compilation failed" } };
    };

    // Run script
    const result = script.run(context) orelse {
        if (try_catch.hasCaught()) {
            const err = error_mod.extractError(isolate, try_catch, allocator) catch {
                return .{ .err = .{ .message = "Error during execution" } };
            };
            return .{ .err = err };
        }
        return .{ .err = .{ .message = "Execution failed" } };
    };

    // Convert result to string
    const result_str = result.toString(context) orelse {
        return .{ .err = .{ .message = "Failed to convert result to string" } };
    };

    const utf8 = result_str.toUtf8(isolate);
    defer utf8.deinit();

    const output = allocator.dupe(u8, utf8.slice()) catch {
        return .{ .err = .{ .message = "Out of memory" } };
    };

    return .{ .ok = output };
}

test "eval simple expression" {
    const allocator = std.testing.allocator;
    const result = runScript("1 + 1", allocator);
    switch (result) {
        .ok => |value| {
            defer allocator.free(value);
            try std.testing.expectEqualStrings("2", value);
        },
        .err => |e| {
            std.debug.print("Error: {s}\n", .{e.message});
            return error.UnexpectedError;
        },
    }
}

test "eval syntax error" {
    const allocator = std.testing.allocator;
    const result = runScript("1 +", allocator);
    switch (result) {
        .ok => |value| {
            defer allocator.free(value);
            return error.ExpectedError;
        },
        .err => |e| {
            // Should get a syntax error with line info
            try std.testing.expect(e.message.len > 0);
            // Syntax errors should have line number
            try std.testing.expect(e.line != null);
        },
    }
}
```

Note: The V8 API may differ from this pseudocode. Key patterns to preserve:
- Create isolate with ArrayBuffer allocator
- Enter isolate scope, handle scope, context scope (in that order)
- Use TryCatch around compile and run
- Convert result to UTF-8 string
- Return union type for success/error

Adapt API calls based on actual v8 module exports discovered in Plan 01.
  </action>
  <verify>
Run `zig build test` - script tests should pass.
Test "1 + 1" returns "2".
Test "1 +" returns error with line number.
  </verify>
  <done>
Script execution module created. Can evaluate JavaScript and return results or meaningful errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate and verify basic evaluation</name>
  <files>src/main.zig</files>
  <action>
Update main.zig to use the script module and verify basic evaluation works.

**src/main.zig:**
```zig
const std = @import("std");
const Engine = @import("engine/v8.zig").Engine;
const script = @import("engine/script.zig");

pub fn main() !void {
    // Initialize V8
    var engine = try Engine.init();
    defer engine.deinit();

    const stdout = std.io.getStdOut().writer();
    const stderr = std.io.getStdErr().writer();

    // Allocator for this execution
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Test basic evaluation
    const test_scripts = [_][]const u8{
        "1 + 1",
        "'hello' + ' ' + 'world'",
        "Math.sqrt(16)",
        "1 +", // Syntax error
    };

    for (test_scripts) |src| {
        try stdout.print("Evaluating: {s}\n", .{src});

        const result = script.runScript(src, allocator);
        switch (result) {
            .ok => |value| {
                defer allocator.free(value);
                try stdout.print("Result: {s}\n\n", .{value});
            },
            .err => |e| {
                const formatted = e.format(allocator) catch e.message;
                defer if (formatted.ptr != e.message.ptr) allocator.free(formatted);
                try stderr.print("{s}\n\n", .{formatted});
            },
        }
    }
}
```

Run and verify output shows:
- "1 + 1" -> "2"
- "'hello' + ' ' + 'world'" -> "hello world"
- "Math.sqrt(16)" -> "4"
- "1 +" -> Error with line number
  </action>
  <verify>
Run `zig build run` and verify output:
1. "1 + 1" evaluates to "2"
2. String concatenation works
3. Math functions work
4. Syntax error produces error message with line info
  </verify>
  <done>
Basic JavaScript evaluation working. Success and error cases both handled correctly.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `zig build test` passes all tests
2. `zig build run` shows correct results for test scripts
3. Syntax error "1 +" produces meaningful error message with line number
4. Valid scripts return their evaluation result
</verification>

<success_criteria>
- src/engine/error.zig extracts errors with line/column info
- src/engine/script.zig compiles and runs JavaScript
- "1 + 1" evaluates to "2"
- Syntax errors return messages with line numbers
- No crashes or memory leaks
</success_criteria>

<output>
After completion, create `.planning/phases/01-v8-foundation/01-02-SUMMARY.md`
</output>
