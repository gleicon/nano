---
phase: 01-v8-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/main.zig
  - src/engine/script.zig
autonomous: false

must_haves:
  truths:
    - "User can run `nano eval \"1 + 1\"` and see `2` printed"
    - "User can run `nano eval \"1 +\"` and see meaningful syntax error"
    - "Memory allocated during script execution is freed when command ends"
  artifacts:
    - path: "src/main.zig"
      provides: "CLI with eval subcommand"
      contains: "eval"
  key_links:
    - from: "src/main.zig"
      to: "src/engine/script.zig"
      via: "imports and calls runScript"
      pattern: "runScript"
---

<objective>
Complete the CLI interface and verify all Phase 1 success criteria are met.

Purpose: This completes Phase 1 by adding the command-line interface (`nano eval "..."`) and wrapping execution in an arena allocator for instant memory cleanup. The checkpoint verifies all three success criteria.

Output: Working `nano eval` command that satisfies all Phase 1 requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-v8-foundation/01-RESEARCH.md

Reference prior plan outputs:
@.planning/phases/01-v8-foundation/01-01-SUMMARY.md
@.planning/phases/01-v8-foundation/01-02-SUMMARY.md

Key patterns:
- Arena allocator wraps entire command execution
- defer arena.deinit() provides instant cleanup
- CLI parses `eval` subcommand and script argument
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CLI with eval subcommand</name>
  <files>src/main.zig</files>
  <action>
Replace main.zig with proper CLI argument parsing.

**src/main.zig:**
```zig
const std = @import("std");
const Engine = @import("engine/v8.zig").Engine;
const script = @import("engine/script.zig");

const usage =
    \\Usage: nano <command> [arguments]
    \\
    \\Commands:
    \\  eval <script>    Evaluate JavaScript and print result
    \\  help             Show this help message
    \\
    \\Examples:
    \\  nano eval "1 + 1"
    \\  nano eval "Math.sqrt(16)"
    \\
;

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    const stderr = std.io.getStdErr().writer();

    // Parse command line arguments
    var args = std.process.args();
    _ = args.skip(); // Skip program name

    const command = args.next() orelse {
        try stderr.print("{s}", .{usage});
        std.process.exit(1);
    };

    if (std.mem.eql(u8, command, "help") or std.mem.eql(u8, command, "--help") or std.mem.eql(u8, command, "-h")) {
        try stdout.print("{s}", .{usage});
        return;
    }

    if (std.mem.eql(u8, command, "eval")) {
        const script_source = args.next() orelse {
            try stderr.print("Error: eval requires a script argument\n\n{s}", .{usage});
            std.process.exit(1);
        };

        try evalCommand(script_source, stdout, stderr);
        return;
    }

    try stderr.print("Unknown command: {s}\n\n{s}", .{ command, usage });
    std.process.exit(1);
}

fn evalCommand(
    script_source: []const u8,
    stdout: anytype,
    stderr: anytype,
) !void {
    // Arena allocator for this entire command
    // All allocations freed instantly when arena.deinit() is called
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit(); // Instant cleanup - satisfies CORE-02

    const allocator = arena.allocator();

    // Initialize V8
    var engine = try Engine.init();
    defer engine.deinit();

    // Execute script
    const result = script.runScript(script_source, allocator);

    switch (result) {
        .ok => |value| {
            try stdout.print("{s}\n", .{value});
        },
        .err => |e| {
            const formatted = e.format(allocator) catch e.message;
            try stderr.print("{s}\n", .{formatted});
            std.process.exit(1);
        },
    }
    // arena.deinit() runs here - all memory freed
}
```

Key points:
- Uses arena allocator wrapping entire evalCommand (CORE-02)
- Parses `eval <script>` subcommand
- Prints result to stdout on success
- Prints error to stderr and exits 1 on failure
  </action>
  <verify>
Build succeeds: `zig build`
Help works: `zig build run -- help`
  </verify>
  <done>
CLI parses eval command and delegates to evalCommand with arena allocator.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build release binary and test CLI</name>
  <files>zig-out/bin/nano</files>
  <action>
Build release binary and verify CLI behavior.

```bash
cd /Users/gleicon/code/zig/nano

# Build release binary
zig build -Doptimize=ReleaseSafe

# Verify binary exists
ls -la zig-out/bin/nano

# Test basic evaluation
./zig-out/bin/nano eval "1 + 1"
# Expected: 2

# Test string operations
./zig-out/bin/nano eval "'hello world'"
# Expected: hello world

# Test math
./zig-out/bin/nano eval "Math.PI"
# Expected: 3.141592653589793

# Test syntax error (should exit 1)
./zig-out/bin/nano eval "1 +" ; echo "Exit code: $?"
# Expected: Error message with line number, Exit code: 1

# Test runtime error
./zig-out/bin/nano eval "undefined_var" ; echo "Exit code: $?"
# Expected: Error message, Exit code: 1

# Test help
./zig-out/bin/nano help
# Expected: Usage information

# Test no args (should show usage)
./zig-out/bin/nano ; echo "Exit code: $?"
# Expected: Usage, Exit code: 1
```
  </action>
  <verify>
All test commands produce expected output.
`nano eval "1 + 1"` outputs exactly `2`.
Syntax errors include line numbers in the message.
Exit codes are correct (0 for success, 1 for errors).
  </verify>
  <done>
Release binary works correctly for all test cases.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete `nano eval` CLI with JavaScript execution and error handling.

Phase 1 requirements implemented:
1. CORE-01: V8 isolate executes JavaScript and returns results
2. CORE-02: Arena allocator provides instant memory cleanup
  </what-built>
  <how-to-verify>
**Test all three Phase 1 success criteria:**

1. **Basic evaluation:**
   ```bash
   cd /Users/gleicon/code/zig/nano
   ./zig-out/bin/nano eval "1 + 1"
   ```
   Expected output: `2`

2. **Syntax error handling:**
   ```bash
   ./zig-out/bin/nano eval "function() {"
   ```
   Expected: Error message mentioning syntax/parse error with line number

3. **Memory cleanup (verify no leaks):**
   ```bash
   # Run multiple times - should not accumulate memory
   for i in {1..10}; do ./zig-out/bin/nano eval "1+$i"; done
   ```
   Expected: All 10 results printed, no crash, no memory growth

**Additional verification:**
- `./zig-out/bin/nano eval "JSON.stringify({a: 1})"` -> `{"a":1}`
- `./zig-out/bin/nano eval "Math.sqrt(2)"` -> `1.4142135623730951`
- `./zig-out/bin/nano help` -> Shows usage
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
Phase 1 is complete when ALL of these are verified:

1. **CORE-01 satisfied:** `nano eval "1 + 1"` returns `2`
2. **CORE-02 satisfied:** Arena allocator wraps execution (code inspection)
3. **Success criterion 1:** `nano eval "1 + 1"` returns `2` to stdout
4. **Success criterion 2:** Syntax errors return meaningful messages
5. **Success criterion 3:** Memory freed when command ends (arena pattern)
</verification>

<success_criteria>
- `nano eval "1 + 1"` prints exactly `2` to stdout
- `nano eval "1 +"` prints error with line number to stderr, exits 1
- Arena allocator wraps evalCommand function
- No memory leaks after repeated execution
- Help text shows usage information
</success_criteria>

<output>
After completion, create `.planning/phases/01-v8-foundation/01-03-SUMMARY.md`
</output>
