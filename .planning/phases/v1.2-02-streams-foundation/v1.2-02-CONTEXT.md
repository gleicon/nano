# Phase v1.2-02: Streams Foundation - Context

**Gathered:** 2026-02-03
**Status:** Ready for planning

<domain>
## Phase Boundary

WinterCG-compliant ReadableStream, WritableStream, and TransformStream classes work independently as JavaScript globals in the V8 runtime. Apps can construct, read, write, pipe, and tee streams. This phase delivers the stream primitives — HTTP response body integration is Phase v1.2-03.

</domain>

<decisions>
## Implementation Decisions

### Spec compliance scope
- Target: Cloudflare Workers-compatible subset of WHATWG Streams
- Include ReadableStream, WritableStream, and TransformStream
- Include pipeTo() and pipeThrough() with full WHATWG pipe options (preventAbort, preventCancel, preventClose)
- Include ReadableStream.tee() for splitting streams
- Include WritableStream abort() with reason
- BYOB (bring your own buffer) readers are NOT in scope

### Stream data types
- Streams accept Uint8Array for binary data and strings for text
- ArrayBuffer accepted but handled as Uint8Array internally
- Streams are encoding-agnostic — string chunks pass through as-is; UTF-8 encoding happens at the HTTP response layer (Phase v1.2-03)
- Configurable max buffer size per app (e.g., 64MB default) in config.json — exceeding the limit errors the stream immediately

### Error & cancellation behavior
- Follow WHATWG spec: controller.error() rejects pending reads immediately, buffered data is lost
- Full WHATWG cancel semantics: cancel reason passed to source, buffered chunks discarded, stream transitions to closed
- WritableStream sink throw → stream enters errored state, writer.closed rejects, no more writes
- Full pipeTo() error options: preventAbort, preventCancel, preventClose supported
- Buffer size overflow → stream enters errored state with clear error message (hard boundary)
- Locked stream access throws spec-compliant TypeError (not custom error types)
- No orphan stream detection — garbage collection handles cleanup

### Developer experience
- ReadableStream supports async iteration: for await (const chunk of stream) { ... }
- Include ReadableStream.from(iterable) convenience constructor for arrays, generators, async iterables
- Informative console.log output: ReadableStream { locked: false, state: 'readable', desiredSize: 1 }
- Configurable queuing strategy per stream: new ReadableStream(source, { highWaterMark: N }) — developers control backpressure thresholds
- Include TextEncoderStream and TextDecoderStream as TransformStream implementations

### Claude's Discretion
- Internal queue implementation details
- Exact default highWaterMark values (follow WHATWG defaults: 1 for counting strategy, ~16KB for byte streams)
- ReadableStream.from() implementation approach
- How to structure the JS/Zig boundary for stream operations
- Test strategy and verification approach

</decisions>

<specifics>
## Specific Ideas

- Workers-compatible API surface is the benchmark — if Workers supports it, NANO should too (within this phase's scope)
- Streams should feel like standard Web APIs, not custom runtime APIs
- Buffer limits are a runtime safety feature, not a developer-facing design choice — error clearly when exceeded

</specifics>

<deferred>
## Deferred Ideas

- BYOB (bring your own buffer) readers — future enhancement if needed
- CompressionStream / DecompressionStream — future phase
- HTTP response body integration — Phase v1.2-03
- Fetch request body streaming — not currently scoped

</deferred>

---

*Phase: v1.2-02-streams-foundation*
*Context gathered: 2026-02-03*
