---
phase: v1.2-02
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/readable_stream.zig
  - src/server/app.zig
  - src/repl.zig
  - src/engine/script.zig
autonomous: true

must_haves:
  truths:
    - "User can create ReadableStream with start/pull/cancel callbacks"
    - "User can get reader via stream.getReader()"
    - "User can read chunks via reader.read()"
    - "User can cancel stream via reader.cancel(reason)"
    - "Controller can enqueue chunks via controller.enqueue(chunk)"
    - "Controller can close stream via controller.close()"
    - "Controller can error stream via controller.error(reason)"
    - "Stream enforces per-app max buffer size limit from config.json"
    - "Buffer overflow transitions stream to errored state with clear message"
    - "Console.log shows readable stream state: ReadableStream { locked: false, state: 'readable', desiredSize: 1 }"
  artifacts:
    - path: "src/api/readable_stream.zig"
      provides: "ReadableStream class, controller, reader implementations"
      min_lines: 400
      exports: ["registerReadableStreamAPI"]
    - path: "src/server/app.zig"
      provides: "ReadableStream registration in app isolate"
      contains: "readable_stream.registerReadableStreamAPI"
    - path: "src/repl.zig"
      provides: "ReadableStream registration in REPL"
      contains: "readable_stream.registerReadableStreamAPI"
    - path: "src/engine/script.zig"
      provides: "ReadableStream registration in script engine"
      contains: "readable_stream.registerReadableStreamAPI"
  key_links:
    - from: "src/api/readable_stream.zig"
      to: "V8 FunctionTemplate"
      via: "registerReadableStreamAPI creates constructor"
      pattern: "v8\\.FunctionTemplate\\.initCallback"
    - from: "ReadableStream constructor"
      to: "ReadableStreamDefaultController"
      via: "passes controller to start callback"
      pattern: "controller.*start"
    - from: "reader.read()"
      to: "internal queue"
      via: "dequeues chunks or waits for pull"
      pattern: "queue.*read|pull"
    - from: "controller.enqueue()"
      to: "buffer size check"
      via: "validates total queue size against _maxBufferSize"
      pattern: "_maxBufferSize|buffer.*limit"
---

<objective>
Implement WinterCG-compliant ReadableStream class with controller and reader.

Purpose: Provide foundation for streaming data in NANO apps, matching Cloudflare Workers API surface. This enables apps to create and consume readable streams independently before HTTP integration (v1.2-03).

Output: Fully functional ReadableStream, ReadableStreamDefaultController, and ReadableStreamDefaultReader classes registered as JavaScript globals.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/gleicon/code/zig/nano/.planning/PROJECT.md
@/Users/gleicon/code/zig/nano/.planning/ROADMAP.md
@/Users/gleicon/code/zig/nano/.planning/STATE.md
@/Users/gleicon/code/zig/nano/.planning/phases/v1.2-02-streams-foundation/v1.2-02-CONTEXT.md

## Existing API Patterns

Reference these for implementation pattern:
@/Users/gleicon/code/zig/nano/src/js.zig
@/Users/gleicon/code/zig/nano/src/api/request.zig
@/Users/gleicon/code/zig/nano/src/api/blob.zig
@/Users/gleicon/code/zig/nano/src/server/app.zig (lines 220-240 for registration pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ReadableStream, ReadableStreamDefaultController, and ReadableStreamDefaultReader</name>
  <files>src/api/readable_stream.zig</files>
  <action>
Create src/api/readable_stream.zig implementing WinterCG-compliant ReadableStream API.

**ReadableStream class:**
- Constructor accepts underlyingSource object with optional start(controller), pull(controller), cancel(reason) callbacks
- Constructor accepts optional strategy object with highWaterMark (default: 1)
- State machine: "readable" | "closed" | "errored"
- Store state in hidden properties: _state, _reader (null or reader reference), _controller, _queue (array of chunks), _closeRequested, _pulling, _maxBufferSize
- locked property (getter): returns true if reader exists
- getReader() method: creates ReadableStreamDefaultReader, throws TypeError if already locked
- cancel(reason) method: calls cancel callback, transitions to closed state
- tee() method: DEFER to Plan 03 (placeholder only)
- Symbol.toStringTag = 'ReadableStream' (for console.log formatting)

**ReadableStreamDefaultController class:**
- Created internally by ReadableStream constructor, passed to start callback
- desiredSize property (getter): returns highWaterMark - queue.length
- enqueue(chunk) method: adds chunk to queue, throws if stream closed/errored
  - **Buffer size enforcement:** Calculate total queue byte size before adding chunk
  - Read per-app max buffer size from App.maxBufferSize (passed during registration, defaults to 64MB if not in config)
  - If total queue size + chunk size exceeds _maxBufferSize, call error() with message "Stream buffer size limit exceeded (max: NMB)"
  - This implements CONTEXT.md locked decision #9 and #12 (configurable buffer size, hard boundary)
- close() method: sets closeRequested flag, closes stream when queue empty
- error(reason) method: transitions stream to errored state, rejects pending reads

**ReadableStreamDefaultReader class:**
- Constructor accepts ReadableStream, locks the stream
- closed property (getter): returns promise that resolves when stream closes
- read() method: returns promise resolving to {value, done} - dequeues from queue or waits for pull
- cancel(reason) method: calls stream.cancel(reason), releases lock
- releaseLock() method: unlocks stream

**Internal queue management:**
- Use hidden _queue property (V8 Array) to buffer chunks
- read() dequeues from queue if available, otherwise calls pull callback and waits
- Backpressure: desiredSize becomes negative when queue exceeds highWaterMark

**Buffer size calculation:**
- For strings: byte length in UTF-8 (use TextEncoder-style byte counting)
- For Uint8Array/ArrayBuffer: byteLength
- For other objects: estimate as 1KB (conservative)
- Store current total size in hidden _queueByteSize property, update on enqueue/dequeue

**Promise handling:**
- Use V8 Promise resolver for read() return values
- Store pending read promises in _pendingReads array property
- Resolve pending reads when enqueue() called

**Error handling:**
- Locked stream access throws TypeError with message "ReadableStream is locked"
- enqueue() after close throws TypeError with message "Cannot enqueue into a closed stream"
- Buffer overflow errors stream immediately (hard boundary, not warning)
- Follow WHATWG spec error semantics from CONTEXT.md

**Pattern notes:**
- Follow src/api/request.zig pattern for constructor + prototype methods
- Use js.CallbackContext for all callbacks
- Use hidden properties (prefixed with _) for internal state
- Register with js.addGlobalClass() like other APIs
- maxBufferSize passed to registerReadableStreamAPI from App config (see how env was passed in v1.2-01)
  </action>
  <verify>
zig build
./zig-out/bin/nano --repl
# Test in REPL:
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("chunk1");
    controller.enqueue("chunk2");
    controller.close();
  }
});
const reader = stream.getReader();
reader.read().then(result => console.log(result));
reader.read().then(result => console.log(result));
reader.read().then(result => console.log(result));
# Expect: {value: "chunk1", done: false}, {value: "chunk2", done: false}, {value: undefined, done: true}

# Test console.log formatting:
console.log(stream);
# Expect: ReadableStream { locked: true, state: 'readable', desiredSize: ... }
  </verify>
  <done>
- ReadableStream constructor works with start callback
- Controller enqueue/close/error methods functional
- Reader read() returns promises with {value, done}
- Stream state machine transitions correctly (readable → closed)
- Locked property prevents multiple readers
- Symbol.toStringTag provides readable console output
- Buffer size limit enforced (stream errors when exceeded)
  </done>
</task>

<task type="auto">
  <name>Task 2: Register ReadableStream API in runtime initialization</name>
  <files>src/server/app.zig, src/repl.zig, src/engine/script.zig</files>
  <action>
Register ReadableStream API in all three runtime initialization locations.

**src/server/app.zig (line ~237, after formdata.registerFormDataAPI):**
```zig
const readable_stream = @import("readable_stream");
// ... in loadApp function after other API registrations:
// Pass maxBufferSize from app config (default: 64MB if not set)
const max_buffer_size = app.config.max_buffer_size_mb orelse 64;
readable_stream.registerReadableStreamAPI(isolate, context, max_buffer_size * 1024 * 1024);
```

**Note:** App.config needs optional max_buffer_size_mb field (u64, defaults to 64). This follows the same pattern as env vars (per-app config field).

**src/repl.zig (line ~338, after formdata.registerFormDataAPI):**
```zig
const readable_stream = @import("readable_stream");
// ... in runRepl function after other API registrations:
// REPL uses default 64MB limit (no config file in REPL mode)
readable_stream.registerReadableStreamAPI(isolate, context, 64 * 1024 * 1024);
```

**src/engine/script.zig (line ~72, after formdata.registerFormDataAPI):**
```zig
const readable_stream = @import("readable_stream");
// ... in executeScript function after other API registrations:
// Script engine uses default 64MB limit
readable_stream.registerReadableStreamAPI(isolate, context, 64 * 1024 * 1024);
```

Follow exact pattern from existing API registrations (console, encoding, url, etc.).
  </action>
  <verify>
zig build
./zig-out/bin/nano --repl
typeof ReadableStream
# Expect: "function"
  </verify>
  <done>
- ReadableStream available as global in server apps
- ReadableStream available in REPL
- ReadableStream available in script engine
- Build completes without errors
- maxBufferSize configuration flows from config.json to stream instances
  </done>
</task>

<task type="auto">
  <name>Task 3: Create basic verification tests</name>
  <files>test/streams/readable/index.js, test/streams/readable/nano.json</files>
  <action>
Create test app demonstrating ReadableStream functionality.

**test/streams/readable/nano.json:**
```json
{
  "port": 8080,
  "apps": [
    {
      "hostname": "readable.local",
      "path": "test/apps/readable-test",
      "max_buffer_size_mb": 1
    }
  ]
}
```

**test/apps/readable-test/index.js:**
```javascript
export default {
  async fetch(request) {
    const url = new URL(request.url());

    // Test 1: Basic enqueue and read
    if (url.pathname === "/basic") {
      const stream = new ReadableStream({
        start(controller) {
          controller.enqueue("Hello");
          controller.enqueue("World");
          controller.close();
        }
      });
      const reader = stream.getReader();
      const results = [];
      let done = false;
      while (!done) {
        const result = await reader.read();
        results.push(result);
        done = result.done;
      }
      return new Response(JSON.stringify(results), {
        headers: { "content-type": "application/json" }
      });
    }

    // Test 2: Pull callback (backpressure simulation)
    if (url.pathname === "/pull") {
      let i = 0;
      const stream = new ReadableStream({
        pull(controller) {
          if (i < 3) {
            controller.enqueue(`chunk${i++}`);
          } else {
            controller.close();
          }
        }
      });
      const reader = stream.getReader();
      const results = [];
      let done = false;
      while (!done) {
        const result = await reader.read();
        results.push(result);
        done = result.done;
      }
      return new Response(JSON.stringify(results), {
        headers: { "content-type": "application/json" }
      });
    }

    // Test 3: Cancel stream
    if (url.pathname === "/cancel") {
      let cancelled = false;
      const stream = new ReadableStream({
        start(controller) {
          controller.enqueue("first");
        },
        cancel(reason) {
          cancelled = true;
        }
      });
      const reader = stream.getReader();
      await reader.read();
      await reader.cancel("test cancel");
      return new Response(JSON.stringify({ cancelled }), {
        headers: { "content-type": "application/json" }
      });
    }

    // Test 4: Error handling
    if (url.pathname === "/error") {
      const stream = new ReadableStream({
        start(controller) {
          controller.enqueue("ok");
          controller.error(new Error("stream error"));
        }
      });
      const reader = stream.getReader();
      await reader.read(); // ok
      try {
        await reader.read(); // should throw
        return new Response("ERROR: should have thrown", { status: 500 });
      } catch (e) {
        return new Response(JSON.stringify({ error: "caught" }), {
          headers: { "content-type": "application/json" }
        });
      }
    }

    // Test 5: Buffer size overflow (1MB limit in config)
    if (url.pathname === "/buffer-overflow") {
      try {
        const stream = new ReadableStream({
          start(controller) {
            // Enqueue 2MB of data (exceeds 1MB limit)
            const chunk = "x".repeat(1024 * 1024); // 1MB
            controller.enqueue(chunk); // OK
            controller.enqueue(chunk); // Should error stream
          }
        });
        return new Response("ERROR: should have errored stream", { status: 500 });
      } catch (e) {
        return new Response(JSON.stringify({
          error: "buffer overflow caught",
          message: e.message
        }), {
          headers: { "content-type": "application/json" }
        });
      }
    }

    // Test 6: Console.log formatting
    if (url.pathname === "/console-format") {
      const stream = new ReadableStream({
        start(controller) {
          controller.enqueue("test");
        }
      });
      // This will be verified manually via server logs
      console.log(stream);
      return new Response(JSON.stringify({ logged: true }), {
        headers: { "content-type": "application/json" }
      });
    }

    return new Response("Not Found", { status: 404 });
  }
};
```

Create test/streams/readable/TEST.md with manual test procedure:
```markdown
# ReadableStream Verification Tests

## Setup
```bash
./zig-out/bin/nano test/streams/readable/nano.json
```

## Tests

1. Basic enqueue/read: `curl http://readable.local:8080/basic`
   - Expect: `[{"value":"Hello","done":false},{"value":"World","done":false},{"done":true}]`

2. Pull callback: `curl http://readable.local:8080/pull`
   - Expect: `[{"value":"chunk0","done":false},{"value":"chunk1","done":false},{"value":"chunk2","done":false},{"done":true}]`

3. Cancel: `curl http://readable.local:8080/cancel`
   - Expect: `{"cancelled":true}`

4. Error handling: `curl http://readable.local:8080/error`
   - Expect: `{"error":"caught"}`

5. Buffer overflow: `curl http://readable.local:8080/buffer-overflow`
   - Expect: `{"error":"buffer overflow caught","message":"Stream buffer size limit exceeded (max: 1MB)"}`

6. Console format: `curl http://readable.local:8080/console-format`
   - Check server logs for: ReadableStream { locked: false, state: 'readable', desiredSize: ... }
```
  </action>
  <verify>
./zig-out/bin/nano test/streams/readable/nano.json
# In another terminal:
curl http://readable.local:8080/basic
curl http://readable.local:8080/pull
curl http://readable.local:8080/cancel
curl http://readable.local:8080/error
curl http://readable.local:8080/buffer-overflow
curl http://readable.local:8080/console-format
# All tests return expected JSON
  </verify>
  <done>
- Test app runs without crashes
- Basic enqueue/read returns correct values
- Pull callback invoked correctly
- Cancel callback fires
- Error propagation works
- Buffer overflow enforcement works (stream errors at limit)
- Console.log shows readable stream state
  </done>
</task>

</tasks>

<verification>
## Requirements Coverage

- **STRM-01**: ReadableStream class with WinterCG-compliant interface ✓
- **STRM-03**: ReadableStreamDefaultReader with read()/cancel() methods ✓
- **STRM-04**: ReadableStreamDefaultController with enqueue()/close()/error() ✓
- **STRM-07**: Backpressure handling via desiredSize ✓
- **CONTEXT.md #9**: Configurable max buffer size per app from config.json ✓
- **CONTEXT.md #12**: Buffer overflow → stream enters errored state ✓
- **CONTEXT.MD #17**: Informative console.log output with Symbol.toStringTag ✓

## Manual Verification

1. Build completes: `zig build`
2. REPL exposes ReadableStream: `./zig-out/bin/nano --repl` → `typeof ReadableStream` → "function"
3. Test app passes all 6 tests (see Task 3 verification)
4. Stream state transitions work correctly
5. Locked stream throws TypeError
6. Buffer size enforcement prevents overflow
</verification>

<success_criteria>
- ReadableStream constructor accepts underlyingSource with start/pull/cancel
- Controller can enqueue chunks, close stream, error stream
- Reader can read chunks via read(), cancel via cancel()
- Backpressure signal (desiredSize) accurate
- Stream locked property prevents multiple readers
- Buffer size limit enforced per-app (from config.json, default 64MB)
- Buffer overflow errors stream immediately with clear message
- Console.log shows ReadableStream { locked, state, desiredSize }
- All test endpoints return expected results
- Requirements STRM-01, STRM-03, STRM-04, STRM-07 validated
</success_criteria>

<output>
After completion, create `.planning/phases/v1.2-02-streams-foundation/v1.2-02-01-SUMMARY.md`
</output>
