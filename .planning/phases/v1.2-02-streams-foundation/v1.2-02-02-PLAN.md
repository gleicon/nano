---
phase: v1.2-02
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/writable_stream.zig
  - src/server/app.zig
  - src/repl.zig
  - src/engine/script.zig
autonomous: true

must_haves:
  truths:
    - "User can create WritableStream with write/close/abort callbacks"
    - "User can get writer via stream.getWriter()"
    - "User can write chunks via writer.write(chunk)"
    - "User can close stream via writer.close()"
    - "User can abort stream via writer.abort(reason)"
    - "Backpressure signal works via writer.ready promise"
    - "Controller can error stream via controller.error(reason)"
    - "Stream enforces per-app max buffer size limit from config.json"
    - "Buffer overflow transitions stream to errored state with clear message"
    - "Console.log shows writable stream state: WritableStream { locked: false, state: 'writable', desiredSize: 1 }"
  artifacts:
    - path: "src/api/writable_stream.zig"
      provides: "WritableStream class, controller, writer implementations"
      min_lines: 400
      exports: ["registerWritableStreamAPI"]
    - path: "src/server/app.zig"
      provides: "WritableStream registration in app isolate"
      contains: "writable_stream.registerWritableStreamAPI"
    - path: "src/repl.zig"
      provides: "WritableStream registration in REPL"
      contains: "writable_stream.registerWritableStreamAPI"
    - path: "src/engine/script.zig"
      provides: "WritableStream registration in script engine"
      contains: "writable_stream.registerWritableStreamAPI"
  key_links:
    - from: "src/api/writable_stream.zig"
      to: "V8 FunctionTemplate"
      via: "registerWritableStreamAPI creates constructor"
      pattern: "v8\\.FunctionTemplate\\.initCallback"
    - from: "WritableStream constructor"
      to: "WritableStreamDefaultController"
      via: "passes controller to start callback"
      pattern: "controller.*start"
    - from: "writer.write()"
      to: "underlyingSink.write"
      via: "calls write callback with chunk"
      pattern: "write.*callback|sink.*write"
    - from: "writer.write()"
      to: "buffer size check"
      via: "validates total queue size against _maxBufferSize"
      pattern: "_maxBufferSize|buffer.*limit"
---

<objective>
Implement WinterCG-compliant WritableStream class with controller and writer.

Purpose: Enable apps to create writable streams for data consumption, matching Cloudflare Workers API. This provides the output counterpart to ReadableStream (Plan 01) before integration work (Plan 03).

Output: Fully functional WritableStream, WritableStreamDefaultController, and WritableStreamDefaultWriter classes registered as JavaScript globals.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/gleicon/code/zig/nano/.planning/PROJECT.md
@/Users/gleicon/code/zig/nano/.planning/ROADMAP.md
@/Users/gleicon/code/zig/nano/.planning/STATE.md
@/Users/gleicon/code/zig/nano/.planning/phases/v1.2-02-streams-foundation/v1.2-02-CONTEXT.md

## Existing API Patterns

Reference these for implementation pattern:
@/Users/gleicon/code/zig/nano/src/js.zig
@/Users/gleicon/code/zig/nano/src/api/request.zig
@/Users/gleicon/code/zig/nano/src/api/blob.zig
@/Users/gleicon/code/zig/nano/src/server/app.zig (lines 220-240 for registration pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WritableStream, WritableStreamDefaultController, and WritableStreamDefaultWriter</name>
  <files>src/api/writable_stream.zig</files>
  <action>
Create src/api/writable_stream.zig implementing WinterCG-compliant WritableStream API.

**WritableStream class:**
- Constructor accepts underlyingSink object with optional start(controller), write(chunk, controller), close(), abort(reason) callbacks
- Constructor accepts optional strategy object with highWaterMark (default: 1)
- State machine: "writable" | "closed" | "errored"
- Store state in hidden properties: _state, _writer (null or writer reference), _controller, _queue (array of pending writes), _closeRequested, _writing, _maxBufferSize
- locked property (getter): returns true if writer exists
- getWriter() method: creates WritableStreamDefaultWriter, throws TypeError if already locked
- abort(reason) method: calls abort callback, transitions to errored state
- Symbol.toStringTag = 'WritableStream' (for console.log formatting)

**WritableStreamDefaultController class:**
- Created internally by WritableStream constructor, passed to start callback
- error(reason) method: transitions stream to errored state, rejects pending writes

**WritableStreamDefaultWriter class:**
- Constructor accepts WritableStream, locks the stream
- closed property (getter): returns promise that resolves when stream closes
- ready property (getter): returns promise that resolves when write backpressure clears
- desiredSize property (getter): returns highWaterMark - queue.length
- write(chunk) method: returns promise, queues chunk, calls sink.write when ready
  - **Buffer size enforcement:** Calculate total queue byte size before adding chunk
  - Read per-app max buffer size from _maxBufferSize (set during stream construction from config)
  - If total queue size + chunk size exceeds _maxBufferSize, reject write promise with error "Stream buffer size limit exceeded (max: NMB)"
  - This implements CONTEXT.md locked decision #9 and #12 (configurable buffer size, hard boundary)
- close() method: returns promise, waits for pending writes, calls sink.close, resolves closed promise
- abort(reason) method: calls stream.abort(reason), releases lock
- releaseLock() method: unlocks stream

**Internal queue management:**
- Use hidden _queue property (V8 Array) to buffer pending write operations
- write() adds to queue, processes sequentially (not parallel)
- Each write resolves its own promise when sink.write callback completes

**Buffer size calculation:**
- For strings: byte length in UTF-8 (use TextEncoder-style byte counting)
- For Uint8Array/ArrayBuffer: byteLength
- For other objects: estimate as 1KB (conservative)
- Store current total size in hidden _queueByteSize property, update on write/complete

**Backpressure handling:**
- desiredSize becomes negative when queue exceeds highWaterMark
- ready promise pending when desiredSize ≤ 0
- ready promise resolves when queue drains below highWaterMark

**Promise handling:**
- Use V8 Promise resolver for write() return values
- Use V8 Promise resolver for ready property
- Use V8 Promise resolver for closed property
- Store promises in hidden properties: _readyPromise, _closedPromise

**Error handling:**
- Locked stream access throws TypeError with message "WritableStream is locked"
- Write after close throws TypeError with message "Cannot write to a closed stream"
- Buffer overflow rejects write promise immediately (hard boundary)
- Sink throw in write callback → stream enters errored state, writer.closed rejects
- Follow WHATWG spec error semantics from CONTEXT.md

**Pattern notes:**
- Follow src/api/request.zig pattern for constructor + prototype methods
- Use js.CallbackContext for all callbacks
- Use hidden properties (prefixed with _) for internal state
- Register with js.addGlobalClass() like other APIs
- maxBufferSize passed to registerWritableStreamAPI from App config (same as ReadableStream pattern)
- Sequential write processing: wait for sink.write to complete before next write
  </action>
  <verify>
zig build
./zig-out/bin/nano --repl
# Test in REPL:
const chunks = [];
const stream = new WritableStream({
  write(chunk) {
    chunks.push(chunk);
  },
  close() {
    console.log("Stream closed");
  }
});
const writer = stream.getWriter();
writer.write("chunk1");
writer.write("chunk2");
writer.close();
# Expect: "Stream closed" logged, chunks array populated

# Test console.log formatting:
console.log(stream);
# Expect: WritableStream { locked: true, state: 'writable', desiredSize: ... }
  </verify>
  <done>
- WritableStream constructor works with write/close callbacks
- Controller error method functional
- Writer write() queues chunks and calls sink.write
- Writer close() waits for pending writes then calls sink.close
- Backpressure via desiredSize and ready promise
- Locked property prevents multiple writers
- Symbol.toStringTag provides readable console output
- Buffer size limit enforced (write rejected when exceeded)
  </done>
</task>

<task type="auto">
  <name>Task 2: Register WritableStream API in runtime initialization</name>
  <files>src/server/app.zig, src/repl.zig, src/engine/script.zig</files>
  <action>
Register WritableStream API in all three runtime initialization locations.

**src/server/app.zig (line ~238, after readable_stream.registerReadableStreamAPI):**
```zig
const writable_stream = @import("writable_stream");
// ... in loadApp function after ReadableStream registration:
// Use same max_buffer_size as ReadableStream
writable_stream.registerWritableStreamAPI(isolate, context, max_buffer_size * 1024 * 1024);
```

**src/repl.zig (line ~339, after readable_stream.registerReadableStreamAPI):**
```zig
const writable_stream = @import("writable_stream");
// ... in runRepl function after ReadableStream registration:
// REPL uses default 64MB limit (no config file in REPL mode)
writable_stream.registerWritableStreamAPI(isolate, context, 64 * 1024 * 1024);
```

**src/engine/script.zig (line ~73, after readable_stream.registerReadableStreamAPI):**
```zig
const writable_stream = @import("writable_stream");
// ... in executeScript function after ReadableStream registration:
// Script engine uses default 64MB limit
writable_stream.registerWritableStreamAPI(isolate, context, 64 * 1024 * 1024);
```

Follow exact pattern from ReadableStream registration (Plan 01).

**Note:** If Plan 01 not yet merged, register after formdata.registerFormDataAPI instead. Update line numbers based on actual file state.
  </action>
  <verify>
zig build
./zig-out/bin/nano --repl
typeof WritableStream
# Expect: "function"
  </verify>
  <done>
- WritableStream available as global in server apps
- WritableStream available in REPL
- WritableStream available in script engine
- Build completes without errors
- maxBufferSize configuration flows from config.json to stream instances
  </done>
</task>

<task type="auto">
  <name>Task 3: Create basic verification tests</name>
  <files>test/streams/writable/index.js, test/streams/writable/nano.json</files>
  <action>
Create test app demonstrating WritableStream functionality.

**test/streams/writable/nano.json:**
```json
{
  "port": 8080,
  "apps": [
    {
      "hostname": "writable.local",
      "path": "test/apps/writable-test",
      "max_buffer_size_mb": 1
    }
  ]
}
```

**test/apps/writable-test/index.js:**
```javascript
export default {
  async fetch(request) {
    const url = new URL(request.url());

    // Test 1: Basic write and close
    if (url.pathname === "/basic") {
      const chunks = [];
      const stream = new WritableStream({
        write(chunk) {
          chunks.push(chunk);
        }
      });
      const writer = stream.getWriter();
      await writer.write("Hello");
      await writer.write("World");
      await writer.close();
      return new Response(JSON.stringify(chunks), {
        headers: { "content-type": "application/json" }
      });
    }

    // Test 2: Backpressure (desiredSize)
    if (url.pathname === "/backpressure") {
      let desiredSizes = [];
      const stream = new WritableStream({
        write(chunk) {
          // Intentionally slow write
        }
      }, { highWaterMark: 2 });
      const writer = stream.getWriter();
      desiredSizes.push(writer.desiredSize); // Should be 2
      writer.write("chunk1");
      desiredSizes.push(writer.desiredSize); // Should be 1
      writer.write("chunk2");
      desiredSizes.push(writer.desiredSize); // Should be 0
      writer.write("chunk3");
      desiredSizes.push(writer.desiredSize); // Should be -1 (backpressure)
      await writer.close();
      return new Response(JSON.stringify(desiredSizes), {
        headers: { "content-type": "application/json" }
      });
    }

    // Test 3: Abort stream
    if (url.pathname === "/abort") {
      let aborted = false;
      const stream = new WritableStream({
        write(chunk) {
          // no-op
        },
        abort(reason) {
          aborted = true;
        }
      });
      const writer = stream.getWriter();
      await writer.write("chunk");
      await writer.abort("test abort");
      return new Response(JSON.stringify({ aborted }), {
        headers: { "content-type": "application/json" }
      });
    }

    // Test 4: Error handling (sink throw)
    if (url.pathname === "/error") {
      const stream = new WritableStream({
        write(chunk) {
          if (chunk === "error") {
            throw new Error("write error");
          }
        }
      });
      const writer = stream.getWriter();
      await writer.write("ok");
      try {
        await writer.write("error");
        return new Response("ERROR: should have thrown", { status: 500 });
      } catch (e) {
        return new Response(JSON.stringify({ error: "caught" }), {
          headers: { "content-type": "application/json" }
        });
      }
    }

    // Test 5: Ready promise (backpressure signal)
    if (url.pathname === "/ready") {
      const stream = new WritableStream({
        write(chunk) {
          // Fast write
        }
      }, { highWaterMark: 1 });
      const writer = stream.getWriter();
      const ready1 = writer.ready; // Should resolve immediately (empty queue)
      await writer.write("chunk1");
      const ready2 = writer.ready; // Should resolve after write completes
      await ready2;
      await writer.close();
      return new Response(JSON.stringify({ ready: "ok" }), {
        headers: { "content-type": "application/json" }
      });
    }

    // Test 6: Buffer size overflow (1MB limit in config)
    if (url.pathname === "/buffer-overflow") {
      const chunks = [];
      const stream = new WritableStream({
        write(chunk) {
          chunks.push(chunk);
        }
      });
      const writer = stream.getWriter();
      try {
        // Write 2MB of data (exceeds 1MB limit)
        const chunk = "x".repeat(1024 * 1024); // 1MB
        await writer.write(chunk); // OK
        await writer.write(chunk); // Should reject
        return new Response("ERROR: should have rejected write", { status: 500 });
      } catch (e) {
        return new Response(JSON.stringify({
          error: "buffer overflow caught",
          message: e.message
        }), {
          headers: { "content-type": "application/json" }
        });
      }
    }

    // Test 7: Console.log formatting
    if (url.pathname === "/console-format") {
      const stream = new WritableStream({
        write(chunk) {
          // no-op
        }
      });
      // This will be verified manually via server logs
      console.log(stream);
      return new Response(JSON.stringify({ logged: true }), {
        headers: { "content-type": "application/json" }
      });
    }

    return new Response("Not Found", { status: 404 });
  }
};
```

Create test/streams/writable/TEST.md with manual test procedure:
```markdown
# WritableStream Verification Tests

## Setup
```bash
./zig-out/bin/nano test/streams/writable/nano.json
```

## Tests

1. Basic write/close: `curl http://writable.local:8080/basic`
   - Expect: `["Hello","World"]`

2. Backpressure: `curl http://writable.local:8080/backpressure`
   - Expect: `[2,1,0,-1]` (desiredSize progression)

3. Abort: `curl http://writable.local:8080/abort`
   - Expect: `{"aborted":true}`

4. Error handling: `curl http://writable.local:8080/error`
   - Expect: `{"error":"caught"}`

5. Ready promise: `curl http://writable.local:8080/ready`
   - Expect: `{"ready":"ok"}`

6. Buffer overflow: `curl http://writable.local:8080/buffer-overflow`
   - Expect: `{"error":"buffer overflow caught","message":"Stream buffer size limit exceeded (max: 1MB)"}`

7. Console format: `curl http://writable.local:8080/console-format`
   - Check server logs for: WritableStream { locked: false, state: 'writable', desiredSize: ... }
```
  </action>
  <verify>
./zig-out/bin/nano test/streams/writable/nano.json
# In another terminal:
curl http://writable.local:8080/basic
curl http://writable.local:8080/backpressure
curl http://writable.local:8080/abort
curl http://writable.local:8080/error
curl http://writable.local:8080/ready
curl http://writable.local:8080/buffer-overflow
curl http://writable.local:8080/console-format
# All tests return expected JSON
  </verify>
  <done>
- Test app runs without crashes
- Basic write/close works correctly
- Backpressure signals via desiredSize accurate
- Abort callback fires
- Error propagation works (sink throw → stream errored)
- Ready promise resolves correctly
- Buffer overflow enforcement works (write rejected at limit)
- Console.log shows writable stream state
  </done>
</task>

</tasks>

<verification>
## Requirements Coverage

- **STRM-02**: WritableStream class with WinterCG-compliant interface ✓
- **STRM-05**: WritableStreamDefaultWriter with write()/close()/abort() methods ✓
- **STRM-06**: WritableStreamDefaultController with error() method ✓
- **STRM-07**: Backpressure handling via desiredSize/ready promise ✓
- **CONTEXT.md #9**: Configurable max buffer size per app from config.json ✓
- **CONTEXT.md #12**: Buffer overflow → stream enters errored state ✓
- **CONTEXT.md #17**: Informative console.log output with Symbol.toStringTag ✓

## Manual Verification

1. Build completes: `zig build`
2. REPL exposes WritableStream: `./zig-out/bin/nano --repl` → `typeof WritableStream` → "function"
3. Test app passes all 7 tests (see Task 3 verification)
4. Stream state transitions work correctly
5. Locked stream throws TypeError
6. Buffer size enforcement prevents overflow
</verification>

<success_criteria>
- WritableStream constructor accepts underlyingSink with write/close/abort
- Controller can error stream
- Writer can write chunks via write(), close via close(), abort via abort()
- Backpressure signals (desiredSize, ready promise) accurate
- Stream locked property prevents multiple writers
- Buffer size limit enforced per-app (from config.json, default 64MB)
- Buffer overflow rejects write promise immediately with clear message
- Console.log shows WritableStream { locked, state, desiredSize }
- All test endpoints return expected results
- Requirements STRM-02, STRM-05, STRM-06, STRM-07 validated
</success_criteria>

<output>
After completion, create `.planning/phases/v1.2-02-streams-foundation/v1.2-02-02-SUMMARY.md`
</output>
