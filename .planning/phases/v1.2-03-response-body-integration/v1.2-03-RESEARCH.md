# Phase v1.2-03: Response Body Integration - Research

**Researched:** 2026-02-07
**Domain:** HTTP Response streaming with ReadableStream integration
**Confidence:** HIGH

## Summary

Phase v1.2-03 integrates ReadableStream (completed in v1.2-02) with HTTP Response objects, enabling fetch() responses to stream their bodies without buffering entire contents. This phase satisfies requirements STRM-08 and STRM-09 by making `Response.body` return a ReadableStream that can be consumed via `.getReader()` or piped to other streams.

The implementation requires two architectural changes: (1) extending the Response class with a `.body` getter that wraps the stored body string into a ReadableStream, and (2) ensuring that Response objects created by fetch() and user code both support streaming consumption. The WinterCG-compliant approach follows Cloudflare Workers and Deno Deploy patterns where Response.body is always a ReadableStream or null.

**Primary recommendation:** Extend Response constructor to accept ReadableStream bodies in addition to strings, and implement lazy evaluation of Response.body as a getter that returns a ReadableStream wrapping the stored body. This keeps backwards compatibility while enabling streaming patterns.

## Standard Stack

### Core (from v1.2-02)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| ReadableStream | v1.2-02 completed | Stream primitives for Response.body | WinterCG requirement, implemented natively in Phase v1.2-02 |
| WritableStream | v1.2-02 completed | Destination for piping Response bodies | Required for pipeTo() patterns |
| TransformStream | v1.2-02 completed | Pipeline transforms (encoding, compression) | Enables response transformation without buffering |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| TextDecoderStream | v1.2-02 completed | Decode binary response bodies to UTF-8 strings | Decoding text-based responses (JSON, HTML) |
| TextEncoderStream | v1.2-02 completed | Encode string bodies to UTF-8 bytes | Encoding response bodies before sending |

### Integration Points
- **v1.2-02 ReadableStream API:** Response.body must return ReadableStream instances
- **fetch.zig Response class:** Must extend with body property/getter
- **app.zig response handler:** Must support ReadableStream bodies in Response constructor
- **http.zig server:** May need small adjustments for streaming response transmission

## Architecture Patterns

### Response Body Lifecycle

**Pattern: Lazy ReadableStream Creation**

```
Response Constructor → Store body (string or ReadableStream)
                   ↓
Response.body getter → Check if already wrapped
                   ↓
                   Return cached ReadableStream or create from body
```

This pattern delays stream creation until `.body` is accessed, supporting both buffered and streaming consumption paths without overhead.

### Streaming Response Pattern (WinterCG-compliant)

```javascript
// fetch() returns Response with streaming body
const response = await fetch("https://example.com/large-file");

// Option 1: Pipe to destination
await response.body.pipeTo(destination);

// Option 2: Manual reader loop
const reader = response.body.getReader();
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  // Process chunk...
}

// Option 3: Async iteration
for await (const chunk of response.body) {
  // Process chunk...
}
```

**Key insight:** Response.body can be null (for HEAD requests, 204 No Content) or ReadableStream. Once read via getReader(), stream is locked and can't be accessed again — consistent with WHATWG spec.

### Backwards Compatibility Pattern

```javascript
// Old API (still works): access buffered body via .text(), .json()
const text = await response.text();

// New API: access streaming body via .body
const reader = response.body.getReader();
```

The existing `.text()` and `.json()` methods must continue to work, internally reading from `.body` (or storing original body string).

### Response Constructor Variants

NANO's Response class must support:
1. `new Response()` → empty body → body = null
2. `new Response(string)` → string body → body wraps in ReadableStream
3. `new Response(ReadableStream)` → streaming body → body = stream
4. `new Response(body, {status, headers})` → with options

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|------------|-------------|-----|
| **Stream from body string** | Custom buffer-to-stream wrapper | ReadableStream from v1.2-02 with `start()` callback | Spec-compliant, handles backpressure, integrates with pipes/tee |
| **Lock stream semantics** | Manual lock tracking on Response | Reuse ReadableStream.getReader() locking | WHATWG-defined behavior, prevents double-reads, consistent with Phase v1.2-02 |
| **Null body handling** | Special cases in consumer code | Follow WHATWG: Response.body === null for empty responses | Prevents downstream bugs, matches worker expectations |
| **Body consumption (text/json)** | Re-implement from stored body string | Read from Response.body stream, cache result | Integrates with streaming, prevents double-read issues |
| **Chunked response encoding** | Manual Transfer-Encoding: chunked | Let http.zig handle streaming transmission | Server layer responsibility, not Response API |

**Key insight:** ReadableStream already solves the hard problems (backpressure, locking, buffering). Don't duplicate—leverage the existing implementation.

## Common Pitfalls

### Pitfall 1: Use-After-Read on Response.body

**What goes wrong:** Code tries to read Response.body twice:
```javascript
const text = await response.body.getReader().read(); // Locks stream
const stream2 = response.body; // Still locked, can't read again
```

**Why it happens:** Developer assumes Response.body is always readable, forgets about reader locking semantics.

**How to avoid:**
- Document that Response.body is locked after getReader() call
- Follow WHATWG: once locked to a reader, subsequent getReader() calls throw TypeError
- Test app using response.text() (reads via .body internally) and verify second read fails appropriately

**Warning signs:**
- Error: "Cannot get reader from locked stream" on second read attempt
- Tests trying to read response body multiple ways

### Pitfall 2: Null Body from Fetch

**What goes wrong:** Streaming code assumes response.body exists:
```javascript
const reader = response.body.getReader(); // Throws if body is null
```

**Why it happens:** Some HTTP responses have no body (204 No Content, HEAD requests). Code doesn't check for null.

**How to avoid:**
- Always guard: `if (response.body !== null) { ... }`
- Design test suite with 204, 304, HEAD responses
- Document which response codes return null body

**Warning signs:**
- TypeError: "Cannot read property of null" on response.body
- HEAD request tests failing

### Pitfall 3: Buffering Entire Large Response

**What goes wrong:** Code reads entire response body into memory, defeating the point of streaming:
```javascript
const buffer = []; // Memory grows unbounded
const reader = response.body.getReader();
while (true) {
  const {done, value} = await reader.read();
  if (done) break;
  buffer.push(value); // OOM on 100MB file
}
```

**Why it happens:** Streaming feels optional; developers don't think about chunk size.

**How to avoid:**
- Document per-app buffer limit (64MB default from v1.2-02)
- Create test with 100MB response; verify buffer limit error occurs
- Example code processes chunks one at a time, not accumulating

**Warning signs:**
- Error: "Stream buffer exceeded" during large file fetch
- Memory usage correlating with response size

### Pitfall 4: Response Body Body Inconsistency

**What goes wrong:** Response initialized with string body, but .body getter creates new ReadableStream each call:
```javascript
const resp = new Response("hello");
const reader1 = resp.body.getReader();
const reader2 = resp.body.getReader(); // Different stream object!
```

**Why it happens:** Tempting to create ReadableStream on-the-fly in getter, but this breaks locking semantics.

**How to avoid:**
- Cache the ReadableStream after first access: store in _bodyStream property
- Getter returns cached stream or null
- Same stream object returned every time until locked

**Warning signs:**
- Multiple getReader() calls succeed when second should lock
- getReader() returns different stream objects on repeated calls

### Pitfall 5: fetch() Response Body with Zig Allocator Mismatch

**What goes wrong:** fetch() reads HTTP response into Zig-allocated buffer, wraps in ReadableStream, but request arena is freed before stream is consumed.

**Why it happens:** v1.2-02 streams designed for use within request context. fetch() creates long-lived Response that outlives request arena.

**How to avoid:**
- ReadableStream created by fetch() must allocate from persistent heap, not request arena
- Design decision: use `std.heap.page_allocator` for fetch-backed streams
- Test: create fetch Response, hold reference, access body after request handler returns (should still work)
- Verify in app.zig that Response from fetch handler is not arena-allocated

**Warning signs:**
- Use-after-free when accessing response.body after request completes
- Memory corruption when streaming large file
- Test app crashes on second chunk read

## Code Examples

Verified patterns from official sources:

### Example 1: Streaming Fetch Response

```typescript
// Source: WHATWG Fetch + Streams integration (https://fetch.spec.whatwg.org/)
// Usage: Large file download without buffering entire file

export default {
  async fetch(request) {
    const response = await fetch("https://example.com/large-file.bin");

    if (!response.body) {
      return new Response("No body", { status: 400 });
    }

    // Pipe response body directly to output
    const reader = response.body.getReader();
    const chunks = [];

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
    }

    // Process chunks incrementally
    return new Response(`Received ${chunks.length} chunks`);
  }
};
```

### Example 2: Response with ReadableStream Body

```typescript
// Source: WHATWG Response + Streams spec integration
// Usage: Application-created Response with streaming body

export default {
  async fetch(request) {
    // Create response with streaming body
    const body = new ReadableStream({
      start(controller) {
        // Enqueue data incrementally
        controller.enqueue("chunk1");
        controller.enqueue("chunk2");
        controller.close();
      }
    });

    return new Response(body, {
      status: 200,
      headers: { "content-type": "text/plain" }
    });
  }
};
```

### Example 3: Transform and Stream Response

```typescript
// Source: v1.2-02 TransformStream + v1.2-03 Response.body integration
// Usage: Decode fetched response and transform it

export default {
  async fetch(request) {
    const response = await fetch("https://example.com/data.txt");

    if (!response.body) return new Response("Empty");

    // Decode UTF-8 bytes to string
    const decodedStream = response.body
      .pipeThrough(new TextDecoderStream());

    // Return transformed response
    return new Response(decodedStream, {
      headers: { "content-type": "text/plain" }
    });
  }
};
```

### Example 4: Null Body Handling

```typescript
// Source: WHATWG Fetch spec (HEAD requests, 204 No Content)
// Usage: Safely handle responses without bodies

export default {
  async fetch(request) {
    const response = await fetch("https://example.com/resource");

    // Check for null body (204, 304, HEAD requests)
    if (response.status === 204 || response.body === null) {
      return new Response(null, { status: 204 });
    }

    // Safe to read body
    const text = await response.text();
    return new Response(text);
  }
};
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Response.text() only | Response.body + Response.text() | WHATWG Fetch 2015+ | Enables streaming without buffering; text()/json() become convenience methods |
| Manual buffer accumulation | ReadableStream with backpressure | Streams standard 2016+ | Prevents unbounded memory use; enables producers to pause writers |
| BYOB readers (complex) | Standard readers + TransformStream | WHATWG focus 2020+ | Simpler mental model; composition via pipes instead of buffer management |

**Deprecated/outdated:**
- Response body as string-only: WHATWG switched to ReadableStream | null model in 2015
- Buffering entire HTTP responses: Streaming pattern now standard across all platforms (Chrome, Firefox, Node.js, Deno, Workers)

## Open Questions

1. **Response.body caching strategy**
   - What we know: Response must return same stream instance if accessed twice (before locking)
   - What's unclear: Should fetch() pre-create the stream or delay until first .body access?
   - Recommendation: Lazy creation with caching — store _bodyStream after first access, return cached on subsequent calls. Reduces memory if .body never accessed.

2. **Interaction with request arena allocator**
   - What we know: v1.2-02 streams can be arena-allocated for request-local use
   - What's unclear: fetch() Response bodies outlive request context; how to allocate?
   - Recommendation: fetch()-created streams use `std.heap.page_allocator` (not request arena). Document that fetch responses are long-lived. Add test verifying memory safety.

3. **HTTP protocol streaming support**
   - What we know: http.zig must transmit Response.body stream to client
   - What's unclear: Does current http.zig support chunked transfer encoding? Does it handle backpressure from streams?
   - Recommendation: Spike on http.zig transmission layer before phase starts. Verify it can iterate Response.body and write chunks without buffering.

4. **Response.text() / Response.json() behavior with streaming**
   - What we know: Existing implementations read via Response.body internally
   - What's unclear: Should Response.text() lock the stream permanently (once called, body can't be read again)?
   - Recommendation: Follow WHATWG: text()/json() acquire reader, read all data, release lock. Stream can be read again. Document this behavior.

## Sources

### Primary (HIGH confidence)
- **WHATWG Fetch Standard** (https://fetch.spec.whatwg.org/) - Authoritative spec for Response.body, ReadableStream integration
- **WHATWG Streams Standard** (https://streams.spec.whatwg.org/) - ReadableStream spec, locking semantics
- **NANO v1.2-02 Streams Foundation** (.planning/phases/v1.2-02-streams-foundation/) - ReadableStream implementation completed in previous phase
- **MDN Response.body** (https://developer.mozilla.org/en-US/docs/Web/API/Response/body) - Current browser implementation reference

### Secondary (MEDIUM confidence)
- **Cloudflare Workers ReadableStream Docs** (https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/) - Verified WinterCG-compatible API surface
- **Deno Deploy Streams** (https://docs.deno.com/deploy/api/runtime-fetch/) - Deno's streaming response implementation reference
- **web.dev Streams Guide** (https://web.dev/articles/streams) - Practical streaming patterns for web

### Code References
- /Users/gleicon/code/zig/nano/src/api/fetch.zig - Current Response implementation (no .body property yet)
- /Users/gleicon/code/zig/nano/src/api/readable_stream.zig - ReadableStream implementation from v1.2-02
- /Users/gleicon/code/zig/nano/test/apps/streams-integration/index.js - Streams test app (can be extended for Response.body tests)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - ReadableStream implemented in v1.2-02, patterns proven across Cloudflare/Deno
- Architecture: HIGH - Clear integration point (Response class), follows established WinterCG patterns
- Pitfalls: MEDIUM-HIGH - Memory safety around fetch() allocator needs spike validation
- Implementation: MEDIUM - Streaming transmission in http.zig layer may need adjustments

**Research date:** 2026-02-07
**Valid until:** 2026-02-21 (stable spec, implementation-dependent validation after coding starts)

**Phase Dependencies:**
- **Blocks:** v1.2-04 (graceful shutdown may need streaming response cleanup)
- **Depends on:** v1.2-02 (ReadableStream, WritableStream, TransformStream)
- **Independent from:** v1.2-01 (env vars)

## Next Steps for Planner

1. **Spike: HTTP transmission layer verification** - Confirm http.zig can iterate Response.body chunks without buffering entire response
2. **Memory model decision** - Decide fetch() response allocation strategy (page_allocator vs arena)
3. **Test matrix planning** - 204/304/HEAD (null body), small responses (< 1KB), large responses (> 10MB), streaming transformation
4. **API boundary** - Lock down exactly which Response constructor variants to support (string vs ReadableStream body)
