---
phase: v1.2-03
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/fetch.zig
  - test/apps/response-body-test/index.js
  - test/response-body.json
autonomous: false

must_haves:
  truths:
    - "Response.body returns ReadableStream for string bodies"
    - "Response.body returns ReadableStream for ReadableStream bodies"
    - "Response.body returns null for empty bodies"
    - "fetch() Response supports streaming consumption via .body.getReader()"
    - "Large response can stream without buffering entire content"
  artifacts:
    - path: "src/api/fetch.zig"
      provides: "Response.body getter, ReadableStream constructor support"
      contains: "fn responseBody"
      min_lines: 800
    - path: "test/apps/response-body-test/index.js"
      provides: "Test endpoints for streaming response bodies"
      exports: ["fetch handler"]
      min_lines: 50
    - path: "test/response-body.json"
      provides: "Test app config for Response.body verification"
      contains: "response-body-test"
  key_links:
    - from: "Response constructor (responseConstructor)"
      to: "ReadableStream wrapping"
      via: "Check if body is ReadableStream, store directly or wrap string"
      pattern: "ReadableStream.*new.*initInstance"
    - from: "Response.body getter (responseBody)"
      to: "Cached _bodyStream or lazy creation"
      via: "Return cached stream or create from _body string"
      pattern: "getValue.*_bodyStream"
    - from: "Response.text() (responseText)"
      to: "Response.body stream reading"
      via: "Acquire reader, read all chunks, release lock"
      pattern: "getReader.*read.*releaseLock"
---

<objective>
Integrate ReadableStream with Response class to enable streaming HTTP response bodies.

Purpose: Satisfy requirements STRM-08 and STRM-09 by making Response.body return a ReadableStream that can be consumed via .getReader() or piped to other streams. This enables fetch() responses to stream their bodies without buffering entire contents, critical for large file downloads and memory-efficient proxying.

Output: Extended Response class with .body getter, ReadableStream constructor support, and backwards-compatible .text()/.json() methods that read from streams.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v1.2-03-response-body-integration/v1.2-03-RESEARCH.md
@.planning/phases/v1.2-02-streams-foundation/v1.2-02-01-SUMMARY.md
@src/api/fetch.zig
@src/api/readable_stream.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Response class with .body getter and ReadableStream constructor support</name>
  <files>src/api/fetch.zig</files>
  <action>
Modify Response implementation to support streaming bodies:

1. **Update responseConstructor function** (line ~424):
   - Check if first argument (body) is a ReadableStream object
   - If ReadableStream: Store directly as `_bodyStream` property
   - If string/null/undefined: Store as `_body` string (existing behavior)
   - Detection pattern: Check for `locked` property on object (ReadableStream has it)

2. **Add Response.body getter** (new function):
   - Create `responseBody` callback function
   - Return null if `_body` is empty string AND no `_bodyStream` exists
   - If `_bodyStream` exists: Return it directly (cached stream)
   - If `_body` string exists: Create ReadableStream wrapping the string, cache in `_bodyStream`, return it
   - ReadableStream creation pattern: Use `start(controller)` callback that enqueues `_body` string then closes
   - Register in response_proto.set() (line ~115, after headers_fn)

3. **Update Response.text() function** (responseText, line ~505):
   - Check if `_bodyStream` exists (body was consumed as stream or constructor received stream)
   - If `_bodyStream`: Create reader via getReader(), read all chunks, concatenate, release lock, return text
   - If no stream: Use existing `_body` string path (backwards compatibility)
   - Handle null body case (return empty string)

4. **Update Response.json() function** (responseJson, line ~520):
   - Call this.text() first to get body string (reuses text() streaming logic)
   - Parse JSON from result (existing behavior)

5. **Update createFetchResponse function** (line ~386):
   - Current behavior stores body as string - keep this for now
   - Future: Could wrap in ReadableStream immediately, but defer for simplicity

**Memory safety notes:**
- ReadableStream created from Response must use page_allocator (not request arena) per research pitfall #5
- Pass isolate's allocator context when creating streams from fetch responses
- Test by holding Response reference across request boundaries

**Follow existing patterns:**
- Use v8.FunctionTemplate.initCallback for responseBody getter
- Use response_proto.set() with PropertyAttribute.None (like status_fn, headers_fn)
- Check ReadableStream detection via object property check (see readable_stream.zig registration)
  </action>
  <verify>
1. Build succeeds: `zig build`
2. Test endpoints respond without errors: `curl http://localhost:3000/test-*` (after Task 2)
3. Response.body returns ReadableStream: Check test output shows `{locked: false}`
4. Response.text() works with both string and stream bodies
  </verify>
  <done>
- Response constructor accepts both string and ReadableStream bodies
- Response.body getter returns ReadableStream or null
- Response.text() reads from stream when present, falls back to string
- Response.json() reuses text() for stream reading
- Build completes without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test app for Response.body streaming patterns</name>
  <files>test/apps/response-body-test/index.js, test/response-body.json</files>
  <action>
Create comprehensive test application for Response.body streaming.

**test/apps/response-body-test/index.js:**

Export default fetch handler with routes:

1. `/test-string-body` - Create Response with string, access .body, verify it's a ReadableStream
   - `new Response("hello world")`
   - Check `response.body !== null`
   - Check `typeof response.body.getReader === 'function'`
   - Return JSON with `{bodyType: "ReadableStream", locked: response.body.locked}`

2. `/test-stream-body` - Create Response with ReadableStream constructor argument
   - Create ReadableStream with start(controller) enqueuing "chunk1", "chunk2", close
   - `new Response(stream)`
   - Verify response.body === original stream reference
   - Return JSON with `{bodyType: "ReadableStream", locked: response.body.locked}`

3. `/test-null-body` - Create Response with null body
   - `new Response(null)`
   - Verify `response.body === null`
   - Return JSON with `{bodyIsNull: true}`

4. `/test-fetch-streaming` - Fetch external URL (if allowed, else mock) and stream response.body
   - Create mock large response via ReadableStream (100KB+ of data across multiple chunks)
   - Get reader via response.body.getReader()
   - Read chunks in while loop, count chunks
   - Release lock after done
   - Return JSON with `{chunksReceived: N, totalBytes: N}`

5. `/test-text-from-stream` - Verify Response.text() works with stream bodies
   - Create Response with ReadableStream body (enqueue "hello", " ", "world", close)
   - Call await response.text()
   - Return JSON with `{text: result, expected: "hello world", match: result === "hello world"}`

6. `/test-json-from-stream` - Verify Response.json() works with stream bodies
   - Create Response with ReadableStream enqueuing JSON string `{"key":"value"}`
   - Call await response.json()
   - Return JSON with `{parsed: result, keyValue: result.key}`

**test/response-body.json:**

```json
{
  "port": 3000,
  "apps": [
    {
      "name": "response-body-test",
      "hostname": "localhost",
      "path": "test/apps/response-body-test/index.js",
      "memory_limit_mb": 128,
      "cpu_timeout_ms": 5000,
      "max_buffer_size_mb": 1
    }
  ]
}
```

Use 1MB buffer limit to test buffer overflow scenarios if needed in future.
  </action>
  <verify>
1. Start NANO with test config: `zig build run -- test/response-body.json`
2. Test each endpoint:
   - `curl http://localhost:3000/test-string-body` → Returns `{bodyType: "ReadableStream", locked: false}`
   - `curl http://localhost:3000/test-stream-body` → Returns `{bodyType: "ReadableStream", locked: false}`
   - `curl http://localhost:3000/test-null-body` → Returns `{bodyIsNull: true}`
   - `curl http://localhost:3000/test-fetch-streaming` → Returns chunk count > 0
   - `curl http://localhost:3000/test-text-from-stream` → Returns `{match: true}`
   - `curl http://localhost:3000/test-json-from-stream` → Returns `{keyValue: "value"}`
3. All endpoints return 200 OK
4. No crashes, no use-after-free errors in logs
  </verify>
  <done>
- Test app exists with 6 endpoints covering streaming patterns
- Test config loads app successfully
- All test endpoints return expected results
- Response.body streaming patterns verified end-to-end
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Response.body streaming integration with ReadableStream support, backwards-compatible text()/json() methods, comprehensive test app</what-built>
  <how-to-verify>
**Setup:**
1. Start NANO with test config:
   ```bash
   cd /Users/gleicon/code/zig/nano
   zig build run -- test/response-body.json
   ```

**Test Response.body returns ReadableStream:**
2. Test string body becomes stream:
   ```bash
   curl http://localhost:3000/test-string-body
   # Expected: {"bodyType": "ReadableStream", "locked": false}
   ```

3. Test ReadableStream constructor argument:
   ```bash
   curl http://localhost:3000/test-stream-body
   # Expected: {"bodyType": "ReadableStream", "locked": false}
   ```

4. Test null body handling:
   ```bash
   curl http://localhost:3000/test-null-body
   # Expected: {"bodyIsNull": true}
   ```

**Test streaming consumption:**
5. Test streaming large response:
   ```bash
   curl http://localhost:3000/test-fetch-streaming
   # Expected: {"chunksReceived": N, "totalBytes": N} where N > 0
   ```

6. Test Response.text() with stream:
   ```bash
   curl http://localhost:3000/test-text-from-stream
   # Expected: {"text": "hello world", "expected": "hello world", "match": true}
   ```

7. Test Response.json() with stream:
   ```bash
   curl http://localhost:3000/test-json-from-stream
   # Expected: {"parsed": {...}, "keyValue": "value"}
   ```

**Verify requirements:**
- [x] STRM-08: Response.body returns ReadableStream for response content
- [x] STRM-09: fetch() Response supports streaming body consumption
- [x] Large responses can stream without buffering entire content (test-fetch-streaming)
- [x] Backwards compatibility: text()/json() still work with string bodies

**Success criteria:**
- All 6 test endpoints return expected JSON responses
- No crashes or memory errors in NANO logs
- Response.body is ReadableStream (not null) for non-empty bodies
- Streaming consumption works via getReader()
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe specific failures</resume-signal>
</task>

</tasks>

<verification>
After human verification approval:

1. **Requirements satisfied:**
   - STRM-08: Response.body returns ReadableStream ✓
   - STRM-09: fetch() Response supports streaming consumption ✓

2. **Must-haves confirmed:**
   - Response.body returns ReadableStream for string bodies ✓
   - Response.body returns ReadableStream for ReadableStream bodies ✓
   - Response.body returns null for empty bodies ✓
   - fetch() Response supports streaming via .body.getReader() ✓
   - Large responses stream without full buffering ✓

3. **Key links verified:**
   - Response constructor → ReadableStream wrapping ✓
   - Response.body getter → cached stream or lazy creation ✓
   - Response.text() → stream reading with reader ✓

4. **Code quality:**
   - No memory leaks (page_allocator used for fetch streams)
   - Backwards compatible (existing Response(string) code still works)
   - WinterCG-compliant (follows WHATWG Fetch + Streams integration)
</verification>

<success_criteria>
**Measurable completion:**

- [ ] `zig build` succeeds without errors
- [ ] Response class has .body getter returning ReadableStream or null
- [ ] Response constructor accepts both string and ReadableStream bodies
- [ ] Response.text() reads from .body stream when present
- [ ] Response.json() reuses text() for consistency
- [ ] Test app runs successfully with all 6 endpoints passing
- [ ] Human verification confirms streaming patterns work end-to-end
- [ ] No memory safety issues or crashes during testing

**Phase goal achieved:** HTTP responses support streaming bodies via ReadableStream (requirements STRM-08 and STRM-09 satisfied)
</success_criteria>

<output>
After completion, create `.planning/phases/v1.2-03-response-body-integration/v1.2-03-01-SUMMARY.md` following the template structure with:
- Frontmatter: subsystem: runtime-api, tags: [streams, response, fetch, wintercg]
- Provides: [response-body-api, response-streaming]
- Affects: [v1.2-04] (graceful shutdown may need to drain streaming responses)
- Key decisions: ReadableStream lazy creation for Response.body, page_allocator for fetch streams
- Duration and completion timestamp
</output>
