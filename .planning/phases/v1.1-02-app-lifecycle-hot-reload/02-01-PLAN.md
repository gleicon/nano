---
phase: v1.1-02-app-lifecycle-hot-reload
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/http.zig
  - src/runtime/event_loop.zig
autonomous: true

must_haves:
  truths:
    - "Config file changes are detected within 3 seconds"
    - "Changed apps reload without server restart"
    - "Unchanged apps continue serving without interruption"
    - "Config parse errors are logged but don't crash server"
  artifacts:
    - path: "src/server/http.zig"
      provides: "Config watcher integration and reload methods"
      contains: "reloadConfig"
    - path: "src/runtime/event_loop.zig"
      provides: "Config watcher timer support"
      contains: "ConfigWatcher"
  key_links:
    - from: "ConfigWatcher"
      to: "HttpServer.reloadConfig"
      via: "timer callback"
      pattern: "reloadConfig"
    - from: "reloadConfig"
      to: "apps HashMap"
      via: "atomic swap"
      pattern: "apps.put"
---

<objective>
Add poll-based config file watching to detect changes and hot-reload apps.

Purpose: Enable zero-downtime app updates by watching config file for changes and reloading apps automatically.
Output: HttpServer with config watcher that polls mtime every 2 seconds and reloads changed apps.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/v1.1-02-app-lifecycle-hot-reload/02-RESEARCH.md
@src/server/http.zig
@src/runtime/event_loop.zig
@src/config.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConfigWatcher to event_loop.zig</name>
  <files>src/runtime/event_loop.zig</files>
  <action>
Add a ConfigWatcher struct to event_loop.zig that:
1. Stores config_path ([]const u8), last_mtime (i128), and a reference to HttpServer
2. Uses xev.Timer to poll every 2 seconds (follow existing PendingTimer pattern)
3. On timer callback:
   - Open config file with std.fs.cwd().openFile()
   - Get stat with file.stat()
   - Compare stat.mtime with stored last_mtime
   - If changed, update last_mtime and call server.reloadConfig()
   - Return .rearm to continue polling
4. Handle errors gracefully (file temporarily inaccessible during editor save)
5. Add debounce: store last_change_time, only reload if 500ms elapsed since last change detected

Pattern from research:
```zig
const ConfigWatcher = struct {
    timer: xev.Timer,
    completion: xev.Completion,
    config_path: []const u8,
    last_mtime: i128,
    last_change_time: i64, // For debounce
    server: *HttpServer, // Forward declare type

    pub fn init(config_path: []const u8, server: *HttpServer) !ConfigWatcher { ... }
    pub fn start(self: *ConfigWatcher, loop: *xev.Loop) void { ... }
    fn onTimer(...) xev.CallbackAction { ... }
};
```

Import HttpServer from http module to get the type. Use `const http = @import("http");` at top.
  </action>
  <verify>
Run `zig build` - compilation succeeds with no errors related to ConfigWatcher.
  </verify>
  <done>
ConfigWatcher struct exists in event_loop.zig with timer-based polling logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add config watcher and reload methods to HttpServer</name>
  <files>src/server/http.zig</files>
  <action>
Add config watching and reload capability to HttpServer:

1. Add new fields to HttpServer struct:
   - config_path: ?[]const u8 = null
   - config_watcher: ?*EventLoop.ConfigWatcher = null (pointer to avoid circular dep issues)
   - config_watcher_storage: ?EventLoop.ConfigWatcher = null (owns the memory)

2. Add method `startConfigWatcher(self: *HttpServer, config_path: []const u8) !void`:
   - Store config_path (dupe it with allocator)
   - Initialize ConfigWatcher with path and self pointer
   - Start watcher on event loop
   - Log "config_watcher_started" with path

3. Add method `reloadConfig(self: *HttpServer) !void`:
   - Log "config_reload_start"
   - Read and parse config file using config_mod.loadConfig()
   - Diff apps: compare new config apps with current apps by hostname
   - For removed apps: call removeApp(hostname)
   - For new apps: load and add to HashMap
   - For changed apps (same hostname, different path): reload
   - Log "config_reload_complete" with counts (added, removed, unchanged)

4. Add method `removeApp(self: *HttpServer, hostname: []const u8) void`:
   - Find app in apps HashMap
   - Remove from HashMap
   - Find in app_storage, call deinit(), swapRemove
   - Free the hostname key
   - Update default_app if needed

5. Add method `addApp(self: *HttpServer, app_cfg: config_mod.AppConfig) !void`:
   - Load app using app_module.loadApp
   - Apply config settings (timeout, memory)
   - Store in app_storage
   - Put in apps HashMap with duped hostname

6. Update serveMultiApp() to start config watcher after loading apps:
   - After loadApps(cfg), call http_server.startConfigWatcher(config_path)
   - Pass config path from loadConfig call site (need to pass it through)

7. Update deinit() to clean up config watcher if active.

Handle errors gracefully - log and continue, don't crash server.
  </action>
  <verify>
Run `zig build` - compiles successfully.
Manual test:
1. Start server with multi-app config
2. Edit config file (change app path or add new app)
3. Within 3 seconds, see log message about config reload
4. Verify requests route to new app
  </verify>
  <done>
HttpServer has config watcher that polls config file and reloads apps on change. Server continues serving during reload.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update main.zig to pass config path for watching</name>
  <files>src/main.zig</files>
  <action>
Update main.zig to pass config path to serveMultiApp:

1. Change serveMultiApp signature in http.zig to accept config_path parameter:
   `pub fn serveMultiApp(cfg: config_mod.Config, config_path: []const u8) !void`

2. In main.zig, pass the config path from command line:
   - Already have config_path from CLI parsing
   - Call http.serveMultiApp(cfg, config_path)

3. In serveMultiApp, after loadApps():
   - Call http_server.startConfigWatcher(config_path)
  </action>
  <verify>
Run `zig build && ./zig-out/bin/nano serve --config test/multi-app/nano.json`
Check logs show "config_watcher_started" message.
  </verify>
  <done>
Config path is passed through to enable config file watching.
  </done>
</task>

</tasks>

<verification>
1. `zig build` succeeds
2. Start server: `./zig-out/bin/nano serve --config test/multi-app/nano.json`
3. Observe "config_watcher_started" in logs
4. Modify test/multi-app/nano.json (e.g., change timeout_ms)
5. Within 3 seconds, observe "config_reload_start" and "config_reload_complete" in logs
6. Requests continue to work during and after reload
</verification>

<success_criteria>
- Config file mtime is checked every 2 seconds
- Changes trigger reloadConfig()
- Apps are added/removed/updated atomically
- Parse errors logged but don't crash server
- No request drops during reload
</success_criteria>

<output>
After completion, create `.planning/phases/v1.1-02-app-lifecycle-hot-reload/02-01-SUMMARY.md`
</output>
