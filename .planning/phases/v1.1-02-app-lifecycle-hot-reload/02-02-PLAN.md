---
phase: v1.1-02-app-lifecycle-hot-reload
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/server/http.zig
autonomous: true

must_haves:
  truths:
    - "GET /admin/apps returns JSON list of loaded apps"
    - "POST /admin/apps adds a new app dynamically"
    - "DELETE /admin/apps?hostname=X removes an app"
    - "POST /admin/reload triggers config reload"
    - "Admin endpoints return appropriate error responses"
  artifacts:
    - path: "src/server/http.zig"
      provides: "Admin API endpoints"
      contains: "handleAdminRequest"
  key_links:
    - from: "handleConnection"
      to: "handleAdminRequest"
      via: "path prefix check"
      pattern: "/admin/"
    - from: "handleAdminRequest"
      to: "addApp/removeApp/reloadConfig"
      via: "method dispatch"
      pattern: "handleListApps|handleAddApp|handleRemoveApp"
---

<objective>
Add admin API endpoints for runtime app management.

Purpose: Enable programmatic control of apps without editing config files - useful for deployments, orchestration, and debugging.
Output: REST API at /admin/* for listing, adding, removing apps and triggering config reload.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/v1.1-02-app-lifecycle-hot-reload/02-RESEARCH.md
@.planning/phases/v1.1-02-app-lifecycle-hot-reload/02-01-SUMMARY.md
@src/server/http.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add admin endpoint routing</name>
  <files>src/server/http.zig</files>
  <action>
Add admin endpoint routing in handleConnection, BEFORE app routing:

1. Add admin_enabled field to HttpServer struct (default true for now)

2. In handleConnection, after parsing path but BEFORE Host header extraction:
```zig
// Handle admin endpoints before app routing
if (std.mem.startsWith(u8, path, "/admin/")) {
    const admin_result = self.handleAdminRequest(conn, method, path, body);
    // Log and return
    const latency_ns: u64 = @intCast(std.time.nanoTimestamp() - start_time);
    self.metrics.recordRequest(latency_ns, admin_result.status >= 400);
    logRequest(request_id, method, path, admin_result.status, admin_result.body.len, @as(f64, @floatFromInt(latency_ns)) / 1_000_000.0);
    return;
}
```

3. Add handleAdminRequest method:
```zig
fn handleAdminRequest(self: *HttpServer, conn: std.net.Server.Connection, method: []const u8, path: []const u8, body: []const u8) struct { status: u16, body: []const u8 } {
    if (std.mem.eql(u8, path, "/admin/apps")) {
        if (std.mem.eql(u8, method, "GET")) {
            return self.handleListApps(conn);
        } else if (std.mem.eql(u8, method, "POST")) {
            return self.handleAddApp(conn, body);
        } else if (std.mem.eql(u8, method, "DELETE")) {
            return self.handleRemoveApp(conn, path, body);
        }
        return self.sendAdminResponse(conn, 405, "{\"error\":\"Method not allowed\"}");
    }
    if (std.mem.eql(u8, path, "/admin/reload")) {
        if (std.mem.eql(u8, method, "POST")) {
            return self.handleReloadConfig(conn);
        }
        return self.sendAdminResponse(conn, 405, "{\"error\":\"Method not allowed\"}");
    }
    if (std.mem.eql(u8, path, "/admin/health")) {
        return self.sendAdminResponse(conn, 200, "{\"status\":\"ok\",\"admin\":true}");
    }
    return self.sendAdminResponse(conn, 404, "{\"error\":\"Not found\"}");
}
```

4. Add helper sendAdminResponse:
```zig
fn sendAdminResponse(self: *HttpServer, conn: std.net.Server.Connection, status: u16, body: []const u8) struct { status: u16, body: []const u8 } {
    self.sendResponse(conn, status, "application/json", body) catch {};
    return .{ .status = status, .body = body };
}
```
  </action>
  <verify>
`zig build` succeeds.
`curl http://localhost:8080/admin/health` returns 200 with JSON.
`curl http://localhost:8080/admin/unknown` returns 404.
  </verify>
  <done>
Admin endpoint routing works, requests to /admin/* are handled before app routing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GET /admin/apps (list apps)</name>
  <files>src/server/http.zig</files>
  <action>
Implement handleListApps to return JSON array of loaded apps:

```zig
fn handleListApps(self: *HttpServer, conn: std.net.Server.Connection) struct { status: u16, body: []const u8 } {
    var buf: [8192]u8 = undefined;
    var fbs = std.io.fixedBufferStream(&buf);
    const writer = fbs.writer();

    writer.writeAll("{\"apps\":[") catch return self.sendAdminResponse(conn, 500, "{\"error\":\"Buffer overflow\"}");

    var first = true;
    var iter = self.apps.iterator();
    while (iter.next()) |entry| {
        if (!first) writer.writeAll(",") catch {};
        first = false;

        const app_ptr = entry.value_ptr.*;
        const memory_pct = app_ptr.getMemoryUsagePercent();

        // Manual JSON building (simpler than std.json for this case)
        std.fmt.format(writer, "{{\"hostname\":\"{s}\",\"path\":\"{s}\",\"memory_percent\":{d:.1},\"timeout_ms\":{d}}}", .{
            entry.key_ptr.*,
            app_ptr.app_path,
            memory_pct,
            app_ptr.timeout_ms,
        }) catch {};
    }

    writer.writeAll("]}") catch {};

    const json_body = fbs.getWritten();
    self.sendResponse(conn, 200, "application/json", json_body) catch {};
    return .{ .status = 200, .body = json_body };
}
```

Response format:
```json
{
  "apps": [
    {
      "hostname": "a.local",
      "path": "./test/multi-app/app-a",
      "memory_percent": 12.5,
      "timeout_ms": 5000
    }
  ]
}
```
  </action>
  <verify>
Start server with multi-app config.
`curl http://localhost:8080/admin/apps` returns JSON with app list.
  </verify>
  <done>
GET /admin/apps returns JSON array of all loaded apps with their stats.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement POST /admin/apps and DELETE /admin/apps</name>
  <files>src/server/http.zig</files>
  <action>
Implement app add and remove endpoints:

1. handleAddApp - POST /admin/apps:
```zig
fn handleAddApp(self: *HttpServer, conn: std.net.Server.Connection, body: []const u8) struct { status: u16, body: []const u8 } {
    // Parse JSON body
    const parsed = std.json.parseFromSlice(std.json.Value, self.allocator, body, .{}) catch {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"Invalid JSON\"}");
    };
    defer parsed.deinit();

    const root = parsed.value;

    // Extract required fields
    const hostname_val = root.object.get("hostname") orelse {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"Missing hostname\"}");
    };
    const path_val = root.object.get("path") orelse {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"Missing path\"}");
    };

    if (hostname_val != .string or path_val != .string) {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"Invalid field types\"}");
    }

    // Check if hostname already exists
    if (self.apps.contains(hostname_val.string)) {
        return self.sendAdminResponse(conn, 409, "{\"error\":\"Hostname already exists\"}");
    }

    // Create AppConfig and add
    const name_val = root.object.get("name");
    const name = if (name_val) |n| if (n == .string) n.string else hostname_val.string else hostname_val.string;

    const timeout = if (root.object.get("timeout_ms")) |t| if (t == .integer) @as(u64, @intCast(t.integer)) else @as(u64, 5000) else @as(u64, 5000);
    const memory = if (root.object.get("memory_mb")) |m| if (m == .integer) @as(usize, @intCast(m.integer)) else @as(usize, 128) else @as(usize, 128);

    const app_cfg = config_mod.AppConfig{
        .name = self.allocator.dupe(u8, name) catch return self.sendAdminResponse(conn, 500, "{\"error\":\"Out of memory\"}"),
        .path = self.allocator.dupe(u8, path_val.string) catch return self.sendAdminResponse(conn, 500, "{\"error\":\"Out of memory\"}"),
        .hostname = self.allocator.dupe(u8, hostname_val.string) catch return self.sendAdminResponse(conn, 500, "{\"error\":\"Out of memory\"}"),
        .port = 0,
        .timeout_ms = timeout,
        .memory_mb = memory,
    };

    self.addApp(app_cfg) catch |err| {
        // Free allocated strings on error
        self.allocator.free(app_cfg.name);
        self.allocator.free(app_cfg.path);
        self.allocator.free(app_cfg.hostname);

        var err_buf: [256]u8 = undefined;
        const err_msg = std.fmt.bufPrint(&err_buf, "{{\"error\":\"Failed to load app: {s}\"}}", .{@errorName(err)}) catch "{\"error\":\"Failed to load app\"}";
        return self.sendAdminResponse(conn, 500, err_msg);
    };

    return self.sendAdminResponse(conn, 201, "{\"success\":true}");
}
```

2. handleRemoveApp - DELETE /admin/apps?hostname=X:
```zig
fn handleRemoveApp(self: *HttpServer, conn: std.net.Server.Connection, path: []const u8, body: []const u8) struct { status: u16, body: []const u8 } {
    _ = body;

    // Parse hostname from query string
    const query_start = std.mem.indexOf(u8, path, "?") orelse {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"Missing hostname parameter\"}");
    };
    const query = path[query_start + 1..];

    // Simple query parsing for hostname=X
    var hostname: ?[]const u8 = null;
    var params = std.mem.splitSequence(u8, query, "&");
    while (params.next()) |param| {
        if (std.mem.startsWith(u8, param, "hostname=")) {
            hostname = param[9..];
            break;
        }
    }

    const target_hostname = hostname orelse {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"Missing hostname parameter\"}");
    };

    // Check app exists
    if (!self.apps.contains(target_hostname)) {
        return self.sendAdminResponse(conn, 404, "{\"error\":\"App not found\"}");
    }

    // Don't allow removing the last app
    if (self.apps.count() == 1) {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"Cannot remove last app\"}");
    }

    self.removeApp(target_hostname);
    return self.sendAdminResponse(conn, 200, "{\"success\":true}");
}
```

3. handleReloadConfig - POST /admin/reload:
```zig
fn handleReloadConfig(self: *HttpServer, conn: std.net.Server.Connection) struct { status: u16, body: []const u8 } {
    if (self.config_path == null) {
        return self.sendAdminResponse(conn, 400, "{\"error\":\"No config file configured\"}");
    }

    self.reloadConfig() catch |err| {
        var err_buf: [256]u8 = undefined;
        const err_msg = std.fmt.bufPrint(&err_buf, "{{\"error\":\"Reload failed: {s}\"}}", .{@errorName(err)}) catch "{\"error\":\"Reload failed\"}";
        return self.sendAdminResponse(conn, 500, err_msg);
    };

    return self.sendAdminResponse(conn, 200, "{\"success\":true}");
}
```
  </action>
  <verify>
Start server with multi-app config.

Test POST /admin/apps:
```bash
curl -X POST http://localhost:8080/admin/apps \
  -H "Content-Type: application/json" \
  -d '{"hostname":"new.local","path":"./test/multi-app/app-a"}'
# Returns 201

curl http://localhost:8080/admin/apps
# Shows new.local in list
```

Test DELETE /admin/apps:
```bash
curl -X DELETE "http://localhost:8080/admin/apps?hostname=new.local"
# Returns 200

curl http://localhost:8080/admin/apps
# new.local no longer in list
```

Test POST /admin/reload:
```bash
curl -X POST http://localhost:8080/admin/reload
# Returns 200
```
  </verify>
  <done>
Admin API supports adding apps via POST, removing via DELETE, and reloading config via POST /admin/reload.
  </done>
</task>

</tasks>

<verification>
1. `zig build` succeeds
2. Start server: `./zig-out/bin/nano serve --config test/multi-app/nano.json`
3. GET /admin/apps returns JSON list
4. POST /admin/apps with valid JSON adds new app
5. DELETE /admin/apps?hostname=X removes app
6. POST /admin/reload triggers config reload
7. Error cases return appropriate 4xx/5xx responses
</verification>

<success_criteria>
- All admin endpoints return JSON responses
- GET /admin/apps lists all loaded apps with stats
- POST /admin/apps adds apps dynamically
- DELETE /admin/apps removes apps (except last one)
- POST /admin/reload triggers config file reload
- Invalid requests return meaningful error messages
</success_criteria>

<output>
After completion, create `.planning/phases/v1.1-02-app-lifecycle-hot-reload/02-02-SUMMARY.md`
</output>
