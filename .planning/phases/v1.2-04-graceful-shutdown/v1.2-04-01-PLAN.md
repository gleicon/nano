---
phase: v1.2-04-graceful-shutdown
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/http.zig
autonomous: true

must_haves:
  truths:
    - "HttpServer tracks active connection count per app hostname"
    - "AppDrainState struct exists with active_connections, draining flag, and drain_start_ns"
    - "app_drain_state map is initialized, populated on app add, and cleaned on app remove"
  artifacts:
    - path: "src/server/http.zig"
      provides: "AppDrainState struct and per-app connection tracking infrastructure"
      contains: "AppDrainState"
  key_links:
    - from: "HttpServer.app_drain_state"
      to: "AppDrainState entries"
      via: "addApp/loadApps registration"
      pattern: "app_drain_state\\.put"
    - from: "removeApp"
      to: "app_drain_state cleanup"
      via: "map remove after app deallocated"
      pattern: "app_drain_state\\.remove"
---

<objective>
Add per-app connection tracking infrastructure to HttpServer. This is the foundation for graceful shutdown: a map from hostname to AppDrainState struct that records active connection count and drain status for each app.

Purpose: Without connection tracking, there is no way to know when it is safe to remove an app or exit the process. This plan provides the data structures that Plans 02 will use for drain logic.
Output: AppDrainState struct, app_drain_state StringHashMap in HttpServer, initialization/registration/cleanup wired into existing app lifecycle methods.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/server/http.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AppDrainState struct and app_drain_state map to HttpServer</name>
  <files>src/server/http.zig</files>
  <action>
Add the AppDrainState struct and app_drain_state field to HttpServer. Place the struct definition before the HttpServer struct declaration.

Add this struct definition (before `pub const HttpServer = struct {`):

```zig
/// Per-app connection tracking for graceful drain
const AppDrainState = struct {
    active_connections: u64 = 0,
    draining: bool = false,
    drain_start_ns: i128 = 0,
};
```

Add this field to the HttpServer struct (after the `admin_enabled` field):

```zig
    // Per-app connection tracking for graceful shutdown
    app_drain_state: std.StringHashMap(AppDrainState),
```

Initialize the map in `HttpServer.init()` (add to the returned HttpServer literal after `.admin_enabled = true,`):

```zig
            .app_drain_state = std.StringHashMap(AppDrainState).init(allocator),
```

Add cleanup to `HttpServer.deinit()` — locate the `deinit` method and add before `self.server.deinit()`:

```zig
        self.app_drain_state.deinit();
```

Note: deinit does NOT free hostname keys — those are already owned by the `apps` map and freed in removeApp. The AppDrainState values contain no heap allocations.
  </action>
  <verify>Run `zig build` — must compile without errors. The struct and map field are purely additive with no behavioral change yet.</verify>
  <done>Project builds cleanly with AppDrainState struct and app_drain_state field in HttpServer.</done>
</task>

<task type="auto">
  <name>Task 2: Register and deregister drain state in app lifecycle methods</name>
  <files>src/server/http.zig</files>
  <action>
Wire app_drain_state registration into addApp, loadApps, and removeApp so the map always reflects current apps.

**In `addApp()` method** — after the app is successfully added to `self.apps` (after `try self.apps.put(hostname_key, app_ptr);`), add:

```zig
        // Register connection tracking for this app
        try self.app_drain_state.put(hostname_key, AppDrainState{});
```

Note: `hostname_key` is the duped hostname already allocated for the apps map. The drain state map uses the same key pointer — it does NOT need a separate dupe because the apps map is the authoritative owner and both maps are cleaned up together.

**In `loadApps()` method** — after the app is added to `self.apps` (locate where `try self.apps.put(hostname_key, app_ptr);` occurs in loadApps and add the same registration):

```zig
        // Register connection tracking for this app
        try self.app_drain_state.put(hostname_key, AppDrainState{});
```

**In `removeApp()` method** — after `_ = self.app_storage.swapRemove(i);` and before the `break`, add drain state cleanup:

```zig
            // Clean up drain state (must be after app is removed from apps map)
            _ = self.app_drain_state.remove(hostname);
```

Important: `removeApp` frees `kv.key` (the hostname) at the end. The `app_drain_state.remove(hostname)` call must happen BEFORE `self.allocator.free(kv.key)` since we use hostname as the key for lookup. Verify the order is: (1) remove from app_drain_state, (2) free hostname.
  </action>
  <verify>Run `zig build` — must compile without errors. Run `./zig-out/bin/nano serve --config test/config.json` and confirm server starts with apps loaded. Check logs show `multi_app_ready` with same app count as before.</verify>
  <done>Server builds and runs in multi-app mode with app_drain_state populated for each loaded app. No behavioral change to request handling yet — this is purely tracking infrastructure.</done>
</task>

</tasks>

<verification>
1. `zig build` succeeds with no errors or warnings
2. Server runs normally with existing config — no regression in behavior
3. Grep confirms: `rg "AppDrainState" src/server/http.zig` shows struct definition and map usage
4. Grep confirms: `rg "app_drain_state" src/server/http.zig` shows init, registration in addApp/loadApps, cleanup in removeApp, and deinit
</verification>

<success_criteria>
- AppDrainState struct defined with active_connections: u64, draining: bool, drain_start_ns: i128
- app_drain_state: std.StringHashMap(AppDrainState) field in HttpServer
- Map initialized in init(), deinited in deinit()
- Entries added in addApp() and loadApps() when app is successfully registered
- Entries removed in removeApp() before hostname key is freed
- Server builds and runs without regression
</success_criteria>

<output>
After completion, create `.planning/phases/v1.2-04-graceful-shutdown/v1.2-04-01-SUMMARY.md`
</output>
