---
phase: v1.2-05
plan: 02
type: execute
wave: 2
depends_on:
  - v1.2-05-01
files_modified:
  - src/api/headers.zig
  - src/api/blob.zig
  - src/api/crypto.zig
autonomous: true

must_haves:
  truths:
    - "headers.delete('foo') causes headers.has('foo') to return false"
    - "headers.append('x', 'a') then headers.append('x', 'b') gives headers.get('x') === 'a, b'"
    - "new Blob([new Uint8Array([72,101,108,108,111])]) creates blob with correct size (5)"
    - "new Blob([new ArrayBuffer(10)]) creates blob with correct size (10)"
    - "crypto.subtle.digest('SHA-256', new Uint8Array([1,2,3])) resolves to ArrayBuffer"
  artifacts:
    - path: "src/api/headers.zig"
      provides: "Headers.delete() removes key, Headers.append() adds multi-value"
      contains: "headersAppend"
    - path: "src/api/blob.zig"
      provides: "Blob constructor accepts ArrayBuffer and Uint8Array parts"
      contains: "isArrayBuffer"
    - path: "src/api/crypto.zig"
      provides: "crypto.subtle.digest accepts ArrayBuffer/Uint8Array input"
      contains: "isArrayBuffer"
  key_links:
    - from: "headers.zig headersDelete"
      to: "V8 object property deletion"
      via: "headers_obj.deleteValue(context, lower_name_str)"
      pattern: "deleteValue"
    - from: "headers.zig headersAppend"
      to: "comma-separated multi-value"
      via: "existing value check + std.fmt.bufPrint"
      pattern: "headersAppend"
    - from: "blob.zig blobConstructor"
      to: "ArrayBuffer/Uint8Array bytes"
      via: "isArrayBuffer / isArrayBufferView branch + BackingStore"
      pattern: "isArrayBuffer"
    - from: "crypto.zig digestCallback"
      to: "ArrayBuffer/Uint8Array bytes"
      via: "isArrayBuffer / isArrayBufferView branch + BackingStore"
      pattern: "isArrayBuffer"
---

<objective>
Fix Headers.delete(), implement Headers.append(), add ArrayBuffer/Uint8Array support to Blob constructor and crypto.subtle.digest.

Purpose: These four fixes complete the WinterCG spec compliance for data mutation and binary input handling.
Output: Headers work correctly for multi-value use cases (Set-Cookie); Blob and crypto.subtle.digest accept binary input.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v1.2-05-api-spec-compliance/v1.2-05-RESEARCH.md
@.planning/phases/v1.2-05-api-spec-compliance/v1.2-05-01-SUMMARY.md

# Binary BackingStore pattern proven in:
@src/api/crypto.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Headers.delete() and implement Headers.append()</name>
  <files>src/api/headers.zig</files>
  <action>
**Fix headersDelete (line ~154-171):**
Replace the `setProp(..., js.undefined_(...))` with actual property deletion. Use V8's deleteValue API:
```zig
fn headersDelete(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    const ctx = js.CallbackContext.init(raw_info);
    if (ctx.argc() < 1) return;

    const name_str = ctx.arg(0).toString(ctx.context) catch return;
    var name_buf: [256]u8 = undefined;
    const name = js.readString(ctx.isolate, name_str, &name_buf);

    var lower_buf: [256]u8 = undefined;
    const lower_name = js.toLower(name, &lower_buf);

    const headers_val = js.getProp(ctx.this, ctx.context, ctx.isolate, "_headers") catch return;
    const headers_obj = js.asObject(headers_val);

    // Actually delete the property
    _ = headers_obj.deleteValue(ctx.context, js.string(ctx.isolate, lower_name));
}
```

NOTE: If `v8.Object.deleteValue` is not available, use an alternative approach: set the value to a sentinel and filter in has/get. Check the v8 module for the correct API. Alternatively, rebuild the _headers object excluding the deleted key.

**Add headersAppend (new function, register in registerHeadersAPI):**
In `registerHeadersAPI`, add after the existing method registrations:
```zig
js.addMethod(proto, isolate, "append", headersAppend);
```

Add the function:
```zig
fn headersAppend(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    const ctx = js.CallbackContext.init(raw_info);
    if (ctx.argc() < 2) return;

    const name_str = ctx.arg(0).toString(ctx.context) catch return;
    var name_buf: [256]u8 = undefined;
    const name = js.readString(ctx.isolate, name_str, &name_buf);

    var lower_buf: [256]u8 = undefined;
    const lower_name = js.toLower(name, &lower_buf);

    const headers_val = js.getProp(ctx.this, ctx.context, ctx.isolate, "_headers") catch return;
    const headers_obj = js.asObject(headers_val);

    const value_str = ctx.arg(1).toString(ctx.context) catch return;
    var val_buf: [4096]u8 = undefined;
    const new_val = js.readString(ctx.isolate, value_str, &val_buf);

    // Check if key already exists
    const existing = js.getProp(headers_obj, ctx.context, ctx.isolate, lower_name) catch null;
    const exists = (existing != null and !existing.?.isUndefined());

    if (exists) {
        // Combine with comma separator per WHATWG spec
        const existing_str = existing.?.toString(ctx.context) catch return;
        var existing_buf: [4096]u8 = undefined;
        const old_val = js.readString(ctx.isolate, existing_str, &existing_buf);

        var combined_buf: [8192]u8 = undefined;
        const combined = std.fmt.bufPrint(&combined_buf, "{s}, {s}", .{ old_val, new_val }) catch return;
        _ = js.setProp(headers_obj, ctx.context, ctx.isolate, lower_name, js.string(ctx.isolate, combined));
    } else {
        // New key: set value and track in _keys
        _ = js.setProp(headers_obj, ctx.context, ctx.isolate, lower_name, js.string(ctx.isolate, new_val));
        const keys_val = js.getProp(ctx.this, ctx.context, ctx.isolate, "_keys") catch return;
        if (keys_val.isArray()) {
            const keys_arr = js.asArray(keys_val);
            const len = keys_arr.length();
            _ = js.setIndex(keys_arr.castTo(v8.Object), ctx.context, len, js.string(ctx.isolate, lower_name).toValue());
        }
    }
}
```
  </action>
  <verify>Build succeeds: `rm -rf /Users/gleicon/code/zig/nano/.zig-cache && zig build -p /Users/gleicon/code/zig/nano/zig-out 2>&1` from /Users/gleicon/code/zig/nano</verify>
  <done>Build passes. headers.zig contains headersAppend function and headersDelete no longer calls setProp with undefined.</done>
</task>

<task type="auto">
  <name>Task 2: Add ArrayBuffer/Uint8Array support to Blob constructor and crypto.subtle.digest</name>
  <files>src/api/blob.zig, src/api/crypto.zig</files>
  <action>
**blob.zig — extend blobConstructor to handle ArrayBuffer/Uint8Array parts:**

The constructor has two loops over parts: one counts size (line ~86-93) and one copies data (line ~130-138). Extend BOTH loops.

Size counting loop extension (after `if (elem.isString())`):
```zig
} else if (elem.isArrayBuffer()) {
    const ab = js.asArrayBuffer(elem);
    total_size += ab.getByteLength();
} else if (elem.isArrayBufferView()) {
    const view = js.asArrayBufferView(elem);
    total_size += view.getByteLength();
}
```

Data copy loop extension (after the `if (elem.isString())` block in the second loop):
```zig
} else if (elem.isArrayBuffer()) {
    const ab = js.asArrayBuffer(elem);
    const ab_len = ab.getByteLength();
    const shared_ptr = ab.getBackingStore();
    const backing_store = v8.BackingStore.sharedPtrGet(&shared_ptr);
    const ab_data = backing_store.getData();
    if (ab_data) |ptr| {
        const remaining = data_buf.len - offset;
        const copy_len = @min(ab_len, remaining);
        const byte_ptr: [*]const u8 = @ptrCast(ptr);
        @memcpy(data_buf[offset .. offset + copy_len], byte_ptr[0..copy_len]);
        offset += copy_len;
    }
} else if (elem.isArrayBufferView()) {
    const view = js.asArrayBufferView(elem);
    const view_len = view.getByteLength();
    const view_offset = view.getByteOffset();
    const ab = view.getBuffer();
    const shared_ptr = ab.getBackingStore();
    const backing_store = v8.BackingStore.sharedPtrGet(&shared_ptr);
    const ab_data = backing_store.getData();
    if (ab_data) |ptr| {
        const remaining = data_buf.len - offset;
        const copy_len = @min(view_len, remaining);
        const byte_ptr: [*]const u8 = @ptrCast(ptr);
        @memcpy(data_buf[offset .. offset + copy_len], byte_ptr[view_offset .. view_offset + copy_len]);
        offset += copy_len;
    }
}
```

Also apply the same pattern to fileConstructor which has the same limitation.

**crypto.zig — extend digestCallback to handle ArrayBuffer/Uint8Array:**

Replace lines ~113-120 (the data-reading block) with a type-aware version:
```zig
// Get data — support string, ArrayBuffer, or ArrayBufferView
var data_storage: [8192]u8 = undefined;
var data: []const u8 = undefined;

if (ctx.arg(1).isArrayBuffer()) {
    const ab = js.asArrayBuffer(ctx.arg(1));
    const ab_len = ab.getByteLength();
    const shared_ptr = ab.getBackingStore();
    const backing_store = v8.BackingStore.sharedPtrGet(&shared_ptr);
    const ab_data = backing_store.getData();
    if (ab_data) |ptr| {
        const copy_len = @min(ab_len, data_storage.len);
        const byte_ptr: [*]const u8 = @ptrCast(ptr);
        @memcpy(data_storage[0..copy_len], byte_ptr[0..copy_len]);
        data = data_storage[0..copy_len];
    } else {
        data = &[_]u8{};
    }
} else if (ctx.arg(1).isArrayBufferView()) {
    const view = js.asArrayBufferView(ctx.arg(1));
    const view_len = view.getByteLength();
    const view_offset = view.getByteOffset();
    const ab = view.getBuffer();
    const shared_ptr = ab.getBackingStore();
    const backing_store = v8.BackingStore.sharedPtrGet(&shared_ptr);
    const ab_data = backing_store.getData();
    if (ab_data) |ptr| {
        const copy_len = @min(view_len, data_storage.len);
        const byte_ptr: [*]const u8 = @ptrCast(ptr);
        @memcpy(data_storage[0..copy_len], byte_ptr[view_offset .. view_offset + copy_len]);
        data = data_storage[0..copy_len];
    } else {
        data = &[_]u8{};
    }
} else {
    // Fall back to string input
    const data_str = ctx.arg(1).toString(ctx.context) catch {
        js.throw(ctx.isolate, "digest: invalid data");
        return;
    };
    data = js.readString(ctx.isolate, data_str, &data_storage);
}
```

Update the downstream hash computation to use `data` (already a slice) instead of `js.readString(...)`.
  </action>
  <verify>Build succeeds: `rm -rf /Users/gleicon/code/zig/nano/.zig-cache && zig build -p /Users/gleicon/code/zig/nano/zig-out 2>&1` from /Users/gleicon/code/zig/nano</verify>
  <done>Build passes. blob.zig contains isArrayBuffer checks in both size and data loops. crypto.zig digestCallback contains isArrayBuffer branch before falling back to string.</done>
</task>

</tasks>

<verification>
After all tasks:
1. `grep -c "isArrayBuffer" src/api/blob.zig` returns >= 4 (two loops, two checks each)
2. `grep -c "isArrayBuffer" src/api/crypto.zig` returns >= 2
3. `grep "headersAppend" src/api/headers.zig` shows function exists
4. `grep "deleteValue\|setProp.*undefined_" src/api/headers.zig` — headersDelete should NOT have setProp with undefined_ anymore
5. `zig build` succeeds
</verification>

<success_criteria>
Build passes. Headers.delete() removes keys. Headers.append() exists. Blob constructor handles binary parts. crypto.subtle.digest handles binary input.
</success_criteria>

<output>
After completion, create `.planning/phases/v1.2-05-api-spec-compliance/v1.2-05-02-SUMMARY.md`
</output>
