# Phase v1.2-05: API Spec Compliance - Research

**Researched:** 2026-02-08
**Domain:** WinterCG/WHATWG API specification compliance (properties vs methods, Headers operations, Blob constructors, crypto input types, console inspection)
**Confidence:** HIGH

## Summary

NANO has implemented many WinterCG APIs but made systematic mistakes in the property/method boundary. The specification and current runtime implementations (Cloudflare Workers, Deno) expect certain values to be readable as properties (via getters) but NANO implemented them as methods requiring `()` calls. Additionally, several supporting methods (Headers.append, Headers.delete, console.log object inspection) have incomplete implementations, and input handling for Blob and crypto.subtle.digest is too restrictive.

This phase fixes 6 categories of issues to make standard Workers code run unmodified:
1. **Properties-as-getters**: Migrate 11 properties from methods to V8 accessor getters
2. **Headers improvements**: Fix delete() to actually remove (not set undefined) and implement append() for multi-value headers
3. **Binary input support**: Accept ArrayBuffer/Uint8Array in Blob constructor and crypto.subtle.digest
4. **Console inspection**: Use JSON.stringify for objects instead of `[object Object]`
5. **File properties**: Apply same getter pattern to File.name and File.lastModified
6. **AbortController.signal**: Ensure it's a getter not a method

The fixes are localized, low-risk (no architecture changes), and can be completed in 3 independent plans.

**Primary recommendation:** Implement properties-as-getters using V8's `setAccessorGetter()` (already proven in response.body and stream.locked). Create a per-property getter function that reads the internal property and returns the value. Follow the exact pattern established in readable_stream.zig lines 24-28 and fetch.zig lines 120-124.

## Standard Stack

### Core Technologies
| Technology | Version | Purpose | Why Standard |
|------------|---------|---------|--------------|
| V8 | bundled in Zig | JavaScript engine | Only option for NANO |
| Zig std.crypto | bundled | SHA-256/384/512, HMAC | Standard library algorithms |
| WHATWG Fetch Standard | current (2026) | Request/Response spec | WinterCG base spec |
| WHATWG File API | current (2026) | Blob/File spec | WinterCG base spec |

### Implementation Patterns
| Pattern | File | Status | Usage |
|---------|------|--------|-------|
| Property getters via setAccessorGetter() | src/api/readable_stream.zig:24-28 | PROVEN | Apply to all 11 properties |
| Headers internal object | src/api/headers.zig:28-34 | EXISTS | Extend for append() |
| Base64 encoding for Blob | src/api/blob.zig:55-62 | EXISTS | Already supports strings |
| Promise returns | src/js module | EXISTS | Use js.retResolvedPromise() |

## Architecture Patterns

### Pattern 1: Property Getters (V8 Accessor Pattern)

**What:** V8 distinguishes between methods (callable with `()`) and property getters (readable without `()`). WinterCG spec requires certain values to be properties.

**When to use:** For all data properties that should be read-only and accessed without parentheses (Response.status, Blob.size, etc.)

**Example from proven code:**
```zig
// Source: src/api/readable_stream.zig:24-28
// Correct: property getter, accessed as stream.locked (not stream.locked())
const locked_getter = v8.FunctionTemplate.initCallback(isolate, readableStreamLockedGetter);
stream_proto.setAccessorGetter(
    js.string(isolate, "locked").toName(),
    locked_getter,
);

// The getter function returns a boolean directly
fn readableStreamLockedGetter(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    const ctx = js.CallbackContext.init(raw_info);
    const val = js.getProp(ctx.this, ctx.context, ctx.isolate, "_locked") catch {
        js.retBool(ctx, false);
        return;
    };
    js.ret(ctx, val);
}
```

**Wrong pattern (current code):**
```zig
// WRONG: This makes it a method, requires .size() call
js.addMethod(blob_proto, isolate, "size", blobSize);
```

### Pattern 2: Headers.append() for Multi-Value Headers

**What:** Headers can store multiple values for the same key (e.g., Set-Cookie). WinterCG spec requires append() to add values without replacing existing ones.

**When to use:** When adding a header that may already exist with a different value.

**Current bug:**
- Headers internally stored as flat object: `{key: "value"}`
- Spec requires: `{key: ["value1", "value2"]}` for multi-valued headers

**Implementation approach:**
1. Store multi-valued headers as arrays internally
2. In `append()`: if value exists and key accepts multiple values, push to array
3. In `get()`: return comma-separated string if array
4. In `set()`: replace entire value (different from append)

**Example from WinterCG spec:**
```javascript
// Standard behavior
const headers = new Headers();
headers.append("set-cookie", "a=1");
headers.append("set-cookie", "b=2");
headers.get("set-cookie"); // "a=1, b=2" per WHATWG spec
```

### Pattern 3: Blob Constructor with Binary Parts

**What:** Blob constructor should accept arrays containing strings, ArrayBuffer, and Uint8Array, not just strings.

**When to use:** When users create Blobs from mixed content types.

**Current implementation limit:**
```zig
// Current: only counts strings (line 89-92)
if (parts_arg.isArray()) {
    const arr = js.asArray(parts_arg);
    var i: u32 = 0;
    while (i < len) : (i += 1) {
        const elem = js.getIndex(arr.castTo(v8.Object), ctx.context, i) catch continue;
        if (elem.isString()) {  // ONLY strings
```

**Required support:**
1. Detect ArrayBuffer/Uint8Array in parts array
2. Extract binary data from backing store
3. Convert to base64 alongside string parts
4. Maintain correct total size

### Pattern 4: crypto.subtle.digest BufferSource Input

**What:** crypto.subtle.digest() should accept ArrayBuffer and Uint8Array as well as strings.

**When to use:** When cryptographic operations work on binary data.

**Current implementation (line 114-120):**
```zig
// Current: converts data to string
const data_str = ctx.arg(1).toString(ctx.context) catch {
    js.throw(ctx.isolate, "digest: invalid data");
    return;
};

var data_buf: [8192]u8 = undefined;
const data = js.readString(ctx.isolate, data_str, &data_buf);
```

**Required: Add branch for ArrayBuffer/Uint8Array:**
```zig
// Check if arg is ArrayBuffer or ArrayBufferView
if (ctx.arg(1).isArrayBuffer()) {
    // Extract bytes from ArrayBuffer backing store
} else if (ctx.arg(1).isArrayBufferView()) {
    // Extract bytes from TypedArray backing store
}
```

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|------------|-------------|-----|
| Custom property getter logic | Wrapper functions | V8 setAccessorGetter() | V8 handles the call properly, no performance overhead |
| Header multi-value storage | Custom linked list | JS array stored internally | Simpler, matches how browsers do it |
| Binary data conversion | Custom conversion logic | V8 BackingStore API (proven in getRandomValues) | Handles endianness, memory safety |
| Base64 encoding for binary | Custom base64 | std.base64 (already used) | Battle-tested, included in std |
| Promise creation | Manual V8 Promise wrapping | js.retResolvedPromise() helper | Already available, less error-prone |

**Key insight:** NANO already has the correct patterns proven in Response.body (setter), ReadableStream.locked (getter), and Uint8Array in getRandomValues (binary handling). The work is mostly copying and adapting existing patterns.

## Common Pitfalls

### Pitfall 1: Forgetting `toName()` When Setting Accessor Getters

**What goes wrong:** Code compiles but property isn't recognized; falls back to method behavior.

**Why it happens:** V8 requires property names to be converted to `v8.Name` type for setAccessorGetter, unlike regular set() which auto-converts.

**How to avoid:** Always append `.toName()` when passing string to setAccessorGetter:
```zig
// WRONG: property not recognized
stream_proto.setAccessorGetter(js.string(isolate, "locked"), locked_getter);

// CORRECT: converts to Name type
stream_proto.setAccessorGetter(
    js.string(isolate, "locked").toName(),
    locked_getter,
);
```

**Warning signs:** Property works with `object.prop()` but fails with `object.prop` (no call)

### Pitfall 2: Headers.delete() Setting to Undefined Instead of Removing

**What goes wrong:** After `headers.delete("key")`, `headers.has("key")` returns true (key still exists with undefined value).

**Why it happens:** Current code at headers.zig:170 sets property to undefined rather than actually removing it.

**How to avoid:** Use V8 API to delete property entirely, or filter out undefined values in iteration methods.

**Verification:** Test sequence:
```javascript
const h = new Headers({foo: "bar"});
h.has("foo"); // true
h.delete("foo");
h.has("foo"); // MUST be false (currently returns true)
h.get("foo"); // MUST return null (currently may return undefined)
```

### Pitfall 3: Blob Constructor Ignoring ArrayBuffer/Uint8Array Parts

**What goes wrong:** `new Blob([new Uint8Array([1,2,3]), "text"])` silently ignores binary parts, resulting in incomplete blob.

**Why it happens:** Constructor only counts string parts (blob.zig:89-92), doesn't handle isArrayBuffer() or isArrayBufferView().

**How to avoid:** Check all part types in size calculation loop:
```zig
const elem = js.getIndex(arr.castTo(v8.Object), ctx.context, i) catch continue;
if (elem.isString()) {
    // existing string handling
} else if (elem.isArrayBuffer()) {
    const ab = js.asArrayBuffer(elem);
    total_size += ab.getByteLength();
} else if (elem.isArrayBufferView()) {
    const view = js.asArrayBufferView(elem);
    total_size += view.getByteLength();
}
```

**Verification:** Constructor must not truncate binary data

### Pitfall 4: crypto.subtle.digest Ignoring Binary Input

**What goes wrong:** `crypto.subtle.digest("SHA-256", new Uint8Array([1,2,3]))` fails with "invalid data" instead of hashing the bytes.

**Why it happens:** Line 114 immediately converts argument to string, which fails for non-string inputs.

**How to avoid:** Check input type before string conversion:
```zig
// Check type first
if (ctx.arg(1).isArrayBuffer() || ctx.arg(1).isArrayBufferView()) {
    // Handle binary path
    const backing = v8.Object.asArrayBuffer(ctx.arg(1)).getBackingStore();
    const bytes = backing.getData();
} else {
    // Fall back to string path
    const data_str = ctx.arg(1).toString(ctx.context) catch {...};
}
```

**Verification:** Both `digest("SHA-256", "data")` and `digest("SHA-256", new Uint8Array([...]))` must work

### Pitfall 5: console.log Using toString() on Objects

**What goes wrong:** `console.log({x: 1})` prints `[object Object]` instead of `{"x":1}`.

**Why it happens:** console.zig:67-71 catches toString() error and prints generic `[object]`.

**How to avoid:** Check object type and use JSON.stringify for objects:
```zig
} else if (value.isObject()) {
    // Use JSON.stringify instead of toString
    const global = context.getGlobal();
    const json_obj = js.getProp(global, ctx.context, ctx.isolate, "JSON") catch {...};
    const stringify_fn = js.getProp(json_obj, ctx.context, ctx.isolate, "stringify") catch {...};
    // Call and print result
}
```

**Verification:** `console.log({x: 1})` must produce valid JSON output, not `[object Object]`

## Code Examples

### Example 1: Property Getter Migration (Blob.size)

**What:** Convert Blob.size from method to getter.

**Before (WRONG):**
```zig
// src/api/blob.zig:16
js.addMethod(blob_proto, isolate, "size", blobSize);

// Call requires: blob.size()
```

**After (CORRECT):**
```zig
// src/api/blob.zig:16
const size_getter = v8.FunctionTemplate.initCallback(isolate, blobSizeGetter);
blob_proto.setAccessorGetter(
    js.string(isolate, "size").toName(),
    size_getter,
);

fn blobSizeGetter(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    const ctx = js.CallbackContext.init(raw_info);

    const size_val = js.getProp(ctx.this, ctx.context, ctx.isolate, "_size") catch {
        js.retNumber(ctx, 0);
        return;
    };
    js.ret(ctx, size_val);
}

// Call is now: blob.size (no parentheses)
```

**Source:** Pattern from src/api/readable_stream.zig:24-28 (proven working)

### Example 2: Blob Constructor Accepting ArrayBuffer

**What:** Accept ArrayBuffer parts in Blob constructor.

**Location:** src/api/blob.zig:73-95

**Before:**
```zig
fn blobConstructor(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    // ... line 80
    if (parts_arg.isArray()) {
        const arr = js.asArray(parts_arg);
        const len = arr.length();

        var i: u32 = 0;
        while (i < len) : (i += 1) {
            const elem = js.getIndex(arr.castTo(v8.Object), ctx.context, i) catch continue;
            if (elem.isString()) {  // ONLY strings counted
                const str = elem.toString(ctx.context) catch continue;
                total_size += str.lenUtf8(ctx.isolate);
            }
        }
    }
```

**After:**
```zig
while (i < len) : (i += 1) {
    const elem = js.getIndex(arr.castTo(v8.Object), ctx.context, i) catch continue;

    if (elem.isString()) {
        const str = elem.toString(ctx.context) catch continue;
        total_size += str.lenUtf8(ctx.isolate);
    } else if (elem.isArrayBuffer()) {
        const ab = js.asArrayBuffer(elem);
        total_size += ab.getByteLength();
    } else if (elem.isArrayBufferView()) {
        const view = js.asArrayBufferView(elem);
        total_size += view.getByteLength();
    }
}
```

**Source:** V8 API patterns proven in crypto.zig getRandomValues and fetch.zig response body handling

### Example 3: Headers.append() for Multi-Value Headers

**What:** Implement Headers.append() to support multiple values.

**Location:** src/api/headers.zig (new method)

**Expected behavior:**
```javascript
const h = new Headers();
h.append("x-custom", "value1");
h.append("x-custom", "value2");
h.get("x-custom"); // "value1, value2"
```

**Implementation sketch:**
```zig
fn headersAppend(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    const ctx = js.CallbackContext.init(raw_info);

    if (ctx.argc() < 2) return;

    const name_str = ctx.arg(0).toString(ctx.context) catch return;
    const value_arg = ctx.arg(1);

    var name_buf: [256]u8 = undefined;
    const name = js.readString(ctx.isolate, name_str, &name_buf);

    var lower_buf: [256]u8 = undefined;
    const lower_name = js.toLower(name, &lower_buf);

    const headers_val = js.getProp(ctx.this, ctx.context, ctx.isolate, "_headers") catch return;
    const headers_obj = js.asObject(headers_val);

    // Check if value already exists
    const existing = js.getProp(headers_obj, ctx.context, ctx.isolate, lower_name) catch null;

    const value_str = value_arg.toString(ctx.context) catch return;

    if (existing != null and !existing.?.isUndefined()) {
        // Value exists: if it's a string, convert to array and append
        // If it's array, push new value
        // For now, simple comma-separation per spec
        const existing_str = existing.?.toString(ctx.context) catch return;
        var combined_buf: [4096]u8 = undefined;
        const combined = std.fmt.bufPrint(&combined_buf, "{s}, {s}", .{
            js.readString(ctx.isolate, existing_str, &combined_buf),
            js.readString(ctx.isolate, value_str, &combined_buf),
        }) catch return;
        _ = js.setProp(headers_obj, ctx.context, ctx.isolate, lower_name, js.string(ctx.isolate, combined));
    } else {
        // New value: set it
        _ = js.setProp(headers_obj, ctx.context, ctx.isolate, lower_name, value_str);
        const keys_val = js.getProp(ctx.this, ctx.context, ctx.isolate, "_keys") catch return;
        if (keys_val.isArray()) {
            const keys_arr = js.asArray(keys_val);
            const len = keys_arr.length();
            _ = js.setIndex(keys_arr.castTo(v8.Object), ctx.context, len, js.string(ctx.isolate, lower_name).toValue());
        }
    }
}
```

**Source:** headers.zig:97-132 (existing set() pattern, extended)

### Example 4: crypto.subtle.digest with ArrayBuffer Input

**What:** Accept ArrayBuffer/Uint8Array in crypto.subtle.digest().

**Location:** src/api/crypto.zig:96-142

**Before:**
```zig
fn digestCallback(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    // ... algorithm parsing ...

    // WRONG: assumes string
    const data_str = ctx.arg(1).toString(ctx.context) catch {
        js.throw(ctx.isolate, "digest: invalid data");
        return;
    };

    var data_buf: [8192]u8 = undefined;
    const data = js.readString(ctx.isolate, data_str, &data_buf);
```

**After:**
```zig
fn digestCallback(raw_info: ?*const v8.C_FunctionCallbackInfo) callconv(.c) void {
    // ... algorithm parsing ...

    var data: []u8 = undefined;
    var data_buf_storage: [8192]u8 = undefined;

    if (ctx.arg(1).isArrayBuffer()) {
        const ab = js.asArrayBuffer(ctx.arg(1));
        const backing = ab.getBackingStore();
        const ptr = backing.getData();
        const len = ab.getByteLength();
        if (ptr) |p| {
            data = @as([*]u8, @ptrCast(p))[0..len];
        }
    } else if (ctx.arg(1).isArrayBufferView()) {
        const view = js.asArrayBufferView(ctx.arg(1));
        const backing = view.getBackingStore();
        const ptr = backing.getData();
        const len = view.getByteLength();
        if (ptr) |p| {
            data = @as([*]u8, @ptrCast(p))[0..len];
        }
    } else {
        // Fall back to string
        const data_str = ctx.arg(1).toString(ctx.context) catch {
            js.throw(ctx.isolate, "digest: invalid data");
            return;
        };
        data = js.readString(ctx.isolate, data_str, &data_buf_storage);
    }

    // Compute hash (existing code)
```

**Source:** crypto.zig getRandomValues (lines 73-94) and fetch.zig response body handling

### Example 5: console.log with Object Inspection

**What:** Use JSON.stringify for objects instead of `[object Object]`.

**Location:** src/api/console.zig:51-74

**Before:**
```zig
fn writeValue(file: std.fs.File, isolate: v8.Isolate, context: v8.Context, value: v8.Value) void {
    if (value.isString()) {
        // ...
    } else if (value.isObject()) {
        const str = value.toString(context) catch {
            file.writeAll("[object]") catch {};  // WRONG: generic output
            return;
        };
```

**After:**
```zig
fn writeValue(file: std.fs.File, isolate: v8.Isolate, context: v8.Context, value: v8.Value) void {
    if (value.isString()) {
        // ...
    } else if (value.isObject()) {
        // Use JSON.stringify for objects
        const global = context.getGlobal();
        const json_val = js.getProp(global, context, isolate, "JSON") catch {
            file.writeAll("[object]") catch {};
            return;
        };
        const json_obj = js.asObject(json_val);
        const stringify_fn_val = js.getProp(json_obj, context, isolate, "stringify") catch {
            file.writeAll("[object]") catch {};
            return;
        };
        const stringify_fn = js.asFunction(stringify_fn_val);

        var args: [1]v8.Value = .{value};
        const result = stringify_fn.call(context, json_val, &args) orelse {
            file.writeAll("[object]") catch {};
            return;
        };

        const result_str = result.toString(context) catch {
            file.writeAll("[object]") catch {};
            return;
        };
        var buf: [4096]u8 = undefined;
        file.writeAll(js.readString(isolate, result_str, &buf)) catch {};
    }
```

**Source:** Existing JSON.parse pattern in request.zig:134-146

## State of the Art

| Issue | Current (WRONG) | Fixed (CORRECT) | When Changed | Impact |
|-------|-----------------|-----------------|--------------|--------|
| Blob.size, Blob.type | Methods requiring () | Getter properties | v1.2-05 | Standard code now works |
| Request.url, .method, .headers | Methods requiring () | Getter properties | v1.2-05 | Workers code compatibility |
| Response.status, .ok, .statusText, .headers | Methods requiring () | Getter properties | v1.2-05 | Response inspection works |
| URL.href, .protocol, .hostname, .port, .pathname, .search, .hash | Methods requiring () | Getter properties | v1.2-05 | URL parsing works |
| AbortController.signal | Method requiring () | Getter property | v1.2-05 | Signal handling standard |
| File.name, File.lastModified | Methods requiring () | Getter properties | v1.2-05 | File API compatibility |
| Headers.delete() | Sets to undefined | Actually removes key | v1.2-05 | Header mutation works |
| Headers.append() | Missing | Supports multi-value | v1.2-05 | Set-Cookie headers work |
| Blob constructor | Strings only | Binary parts supported | v1.2-05 | Binary blob creation works |
| crypto.subtle.digest | Strings only | ArrayBuffer/Uint8Array | v1.2-05 | Binary hashing works |
| console.log objects | `[object Object]` | JSON stringified | v1.2-05 | Debugging output useful |

**Deprecated/outdated:** None — this is first-time fixes, not replacements

## Open Questions

None identified during research. The specification is clear, patterns are proven in existing code, and the scope is well-defined.

## Sources

### Primary (HIGH confidence)

- **WHATWG Fetch Standard** - Official Request/Response specifications at https://fetch.spec.whatwg.org/
  - Verified: Response properties (status, ok, statusText, headers) are read-only properties, not methods
  - Verified: Headers.delete() removes keys entirely, Headers.append() appends multi-values

- **WHATWG File API** - Official Blob/File specifications
  - Verified: Blob.size and Blob.type are read-only properties
  - Verified: Blob constructor accepts array of mixed types (strings, ArrayBuffer, Uint8Array)

- **MDN Web Docs - Blob** at https://developer.mozilla.org/en-US/docs/Web/API/Blob
  - Verified: size and type are properties (not methods), documented as read-only

- **MDN Web Docs - Headers** at https://developer.mozilla.org/en-US/docs/Web/API/Headers
  - Verified: delete() removes header entirely
  - Verified: append() appends new values without replacing existing ones

- **NANO Project Memory** - V8 binding patterns (MEMORY.md)
  - Verified: Use setAccessorGetter() not set() for WinterCG spec properties
  - Proven: Response.body and ReadableStream.locked already use this pattern correctly

- **NANO Codebase** - Working implementations as reference
  - src/api/readable_stream.zig:24-28 — ReadableStream.locked getter pattern (PROVEN)
  - src/api/fetch.zig:120-124 — Response.body getter pattern (PROVEN)
  - src/api/headers.zig — Headers multi-key tracking with arrays (PROVEN)

### Secondary (MEDIUM confidence)

- **MDN Web Docs - crypto.subtle.digest** at https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
  - Verified: digest() accepts "a BufferSource, which is an ArrayBuffer or an ArrayBufferView"
  - Not verified: exact V8 API for extracting bytes (inferred from getRandomValues pattern)

## Metadata

**Confidence breakdown:**
- **Standard stack:** HIGH — WHATWG specs are authoritative, MDN documents confirmed
- **Architecture patterns:** HIGH — exact patterns proven in existing NANO code (Response.body, stream.locked)
- **Pitfalls:** HIGH — discovered during v1.2-04 audit, bugs are reproducible
- **Code examples:** MEDIUM-HIGH — patterns are proven, some APIs (Blob binary parts) inferred from V8 API docs

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (30 days — specs are stable, only code patterns subject to change)

**Known limitations out of scope:**
- B-01: Stack buffer limits (64KB) — requires allocator refactor
- B-02: Synchronous fetch blocks event loop — requires async I/O integration
- B-03: WritableStream async sinks — requires Promise queue
- B-04: crypto.subtle RSA/ECDSA/encrypt/decrypt — significant new crypto
- B-05: ReadableStream.tee() data loss — requires branch queuing
- B-08: URL read-only properties — not in v1.2-05 scope
