---
phase: v1.2-01
verified: 2026-02-02T00:00:00Z
status: passed
score: 4/4 must-haves verified
re_verification: false
---

# Phase v1.2-01: Per-App Environment Variables Verification Report

**Phase Goal:** Apps can access isolated environment variables from config

**Verified:** 2026-02-02
**Status:** PASSED ✓
**Score:** 4/4 truths verified

---

## Goal Achievement

### Observable Truths

| # | Truth | Status | Evidence |
|---|-------|--------|----------|
| 1 | App can read environment variables via second parameter to fetch handler | ✓ VERIFIED | `src/server/app.zig:506-509` defines `fetch_args[2]` with env_obj; `src/server/app.zig:502` calls `buildEnvObject()` |
| 2 | Environment variables are defined in config.json per app | ✓ VERIFIED | `src/config.zig:182-216` parses `env` field from JSON config; test config at `test/env-test/nano.json` demonstrates JSON env object |
| 3 | App A cannot access App B's environment variables | ✓ VERIFIED | `src/server/app.zig:349-396` shows each App deep-copies env from AppConfig; isolated HashMap per app ensures isolation |
| 4 | Environment variables update when config is hot-reloaded | ✓ VERIFIED | `src/server/http.zig:100, 287` calls `loadApp()` with `app_cfg.env`; new App gets fresh copy of new config's env (line 350-396 in app.zig) |

**Score:** 4/4 truths verified

---

## Required Artifacts

| Artifact | Expected | Status | Evidence |
|----------|----------|--------|----------|
| `src/config.zig` | AppConfig struct with env field, JSON parsing for env object | ✓ VERIFIED | Line 11: `env: ?std.StringHashMap([]const u8)` defined; Lines 182-216: env parsing implemented; Lines 33-42: cleanup in deinit() |
| `src/server/app.zig` | buildEnvObject helper, 2-parameter fetch invocation, App owns env HashMap | ✓ VERIFIED | Line 47: `env: std.StringHashMap([]const u8)` field in App struct; Lines 425-440: `buildEnvObject()` function; Lines 506-509: 2-param fetch invocation with env |

**All artifacts substantive:**
- `src/config.zig`: 335 lines (target: 150+) ✓
- `src/server/app.zig`: 670 lines (target: 200+) ✓
- Both files have exports and no stub patterns (no TODO/FIXME/placeholder)

**All artifacts wired:**
- `buildEnvObject` imported and called in `handleRequest` (line 502)
- `env` field in App struct initialized in `loadApp` (lines 349-396)
- `env` copied from AppConfig during app load (line 100, 287 in http.zig)

---

## Key Link Verification

### src/config.zig → src/server/app.zig: Env Copying on Load

| From | To | Via | Status | Details |
|------|----|----|--------|---------|
| `src/config.zig:AppConfig.env` | `src/server/app.zig:App.env` | `loadApp()` deep copy | ✓ WIRED | Lines 349-396 in app.zig: For each entry in `app_config_env`, allocate and dupe key and value, put into `env_map` |

**Verification:**
- AppConfig owns original env HashMap (config.zig)
- App deep-copies during loadApp (app.zig:350-396)
- Each key and value are duped with allocator (lines 353, 367)
- Error handling with errdefer cleanup (lines 365, 380)
- App owns the copied HashMap and frees it in deinit (lines 69-74)

**Pattern confirmed:** Deep copy ownership model prevents use-after-free on hot reload

### src/server/app.zig → fetch handler: Env Object Creation and 2-Param Call

| From | To | Via | Status | Details |
|------|----|----|--------|---------|
| `App.env HashMap` | `fetch(request, env)` call | `buildEnvObject()` + 2-arg invocation | ✓ WIRED | Line 502: `buildEnvObject()` creates V8 object; Lines 506-509: 2-element array passed to fetch_fn.call() |

**Verification:**
- Line 502: `const env_obj = buildEnvObject(isolate, context, &app.env);`
- Lines 506-509: `var fetch_args: [2]v8.Value = .{ request_obj, env_obj }`
- Line 510: `fetch_fn.call(context, exports, &fetch_args)`
- buildEnvObject (lines 425-440) iterates app_env HashMap and builds V8 object

**Pattern confirmed:** Environment passed as second parameter to fetch handler (Cloudflare Workers pattern)

---

## Requirements Coverage

| Requirement | Phase | Status | Evidence |
|-------------|-------|--------|----------|
| ENVV-01: Config JSON supports `env` object per app | v1.2-01 | ✓ SATISFIED | config.zig lines 182-216 parse env field; test config demonstrates JSON structure |
| ENVV-02: Env vars injected as second parameter to fetch handler | v1.2-01 | ✓ SATISFIED | app.zig lines 502-509 pass env as fetch_args[1] |
| ENVV-03: Complete isolation — app A cannot access app B's env | v1.2-01 | ✓ SATISFIED | Each App owns deep-copied env HashMap (lines 349-396); no shared references between apps |
| ENVV-04: Env vars updated on config reload | v1.2-01 | ✓ SATISFIED | http.zig loads new AppConfig; loadApp creates fresh App with fresh env copy (lines 100, 287) |

**Coverage:** 4/4 requirements satisfied

---

## Code Quality Checks

### No Stub Patterns Found
- ✓ No TODO/FIXME comments in modified files
- ✓ No placeholder text or "coming soon" messages
- ✓ No empty returns or console.log-only implementations
- ✓ All functions have substantive implementations

### Memory Safety
**Verified patterns:**
1. **Config layer (src/config.zig):**
   - Lines 196-213: JSON object iterated, each string entry duped
   - Lines 38-40: deinit() frees both keys and values before HashMap deinit
   - Lines 187-194: errdefer cleanup on partial allocation failure

2. **App layer (src/server/app.zig):**
   - Lines 350-396: Deep copy from AppConfig.env to App.env with full string duping
   - Lines 365, 380: errdefer cleanup for each allocation
   - Lines 69-74: App.deinit() frees all keys and values before HashMap deinit

3. **Hot reload safety:**
   - Old App freed completely (App.deinit calls env.deinit)
   - New App gets fresh deep copy of new config's env
   - No dangling pointers possible (deep copy ownership model)

### Compilation
- ✓ `zig build` succeeds with no errors or warnings

---

## Test Artifacts

**Config files created:**
- `test/env-test/nano.json` - Single app with env vars (API_KEY, DEBUG)
- `test/env-isolation/nano.json` - Two apps (app-a, app-b) with distinct env vars

**Test apps created:**
- `test/apps/env-test/index.js` - Returns env access test (hasEnv, apiKey, debug)
- `test/apps/env-a/index.js` - Returns full env object for app-a
- `test/apps/env-b/index.js` - Returns full env object for app-b

**Test documentation:**
- Manual testing procedure documented in plan (Task 3)
- Isolation test verified by running both app-a and app-b requests
- Hot reload test documented (modify config and verify updates)
- Memory safety test documented (valgrind/instruments testing)

---

## Implementation Summary

### What Was Verified

1. **Config Parsing (src/config.zig)**
   - ✓ AppConfig struct extended with `env: ?std.StringHashMap([]const u8)`
   - ✓ parseConfig() parses JSON "env" object into HashMap
   - ✓ All strings duped by config allocator
   - ✓ Config.deinit() properly cleans up HashMap (keys, values, then HashMap)
   - ✓ Handles missing env field gracefully (null if not present)

2. **Runtime Injection (src/server/app.zig)**
   - ✓ App struct owns env HashMap (not reference to AppConfig)
   - ✓ loadApp() deep-copies env from AppConfig
   - ✓ Each key and value allocated independently (prevents use-after-free)
   - ✓ buildEnvObject() converts HashMap to V8 object
   - ✓ handleRequest() passes env as second parameter to fetch handler
   - ✓ App.deinit() cleans up env HashMap

3. **Integration (src/server/http.zig)**
   - ✓ loadApp() calls pass app_cfg.env parameter (line 100, 287)
   - ✓ Admin API AppConfig creation sets env = null (line 729)
   - ✓ No missing struct fields in any AppConfig initialization

4. **Verification (test/ directory)**
   - ✓ Test configs demonstrate env object syntax
   - ✓ Test apps verify fetch handler receives env parameter
   - ✓ Isolation configs show different env vars per app
   - ✓ Manual testing procedures documented

---

## Gaps or Issues

**NONE FOUND**

All 4 must-have truths verified. All 2 required artifacts verified (exist, substantive, wired). All 4 requirements satisfied. Code compiles successfully. No stub patterns detected.

---

## Conclusion

Phase v1.2-01 goal achieved: **Apps can access isolated environment variables from config**

The implementation:
- Parses environment variables from config.json per app
- Passes env vars as second parameter to fetch handler (Workers-compatible API)
- Ensures complete isolation between apps (deep-copied HashMap per app)
- Handles hot reload safely (new App owns fresh copy of new config's env)
- Maintains memory safety (no use-after-free possible)

All must-haves verified. Ready for v1.2-02 (Streams Foundation).

---

*Verified: 2026-02-02*
*Verifier: Claude (gsd-verifier)*
