---
phase: v1.2-01
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.zig
  - src/server/app.zig
autonomous: true

must_haves:
  truths:
    - "App can read environment variables via second parameter to fetch handler"
    - "Environment variables are defined in config.json per app"
    - "App A cannot access App B's environment variables"
    - "Environment variables update when config is hot-reloaded"
  artifacts:
    - path: "src/config.zig"
      provides: "AppConfig struct with env field, JSON parsing for env object"
      contains: "env: ?std.StringHashMap"
      min_lines: 150
    - path: "src/server/app.zig"
      provides: "buildEnvObject helper, 2-parameter fetch invocation, App owns env HashMap"
      contains: "buildEnvObject"
      min_lines: 200
  key_links:
    - from: "src/config.zig"
      to: "src/server/app.zig"
      via: "AppConfig.env entries copied to App-owned HashMap during loadApp"
      pattern: "env:.*StringHashMap"
    - from: "src/server/app.zig"
      to: "fetch handler"
      via: "buildEnvObject creates V8 object, passed as second argument"
      pattern: "fetch_args:.*\\[2\\]"
---

<objective>
Enable per-app environment variables with complete isolation and hot-reload support.

Purpose: Allow apps to access isolated configuration without global scope pollution, following Cloudflare Workers pattern (fetch handler receives env as second parameter).

Output: Config-driven environment variables accessible in app fetch handlers, automatically updated on config reload.
</objective>

<execution_context>
@/Users/gleicon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v1.2-01-per-app-env-vars/v1.2-01-RESEARCH.md
@src/config.zig
@src/server/app.zig
@src/js.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Config Parsing for Environment Variables</name>
  <files>src/config.zig</files>
  <action>
Extend AppConfig struct and config parsing to support per-app environment variables:

1. **AppConfig struct extension** (line 4):
   - Add field: `env: ?std.StringHashMap([]const u8)`
   - Optional type (null if no env defined in config)

2. **parseConfig function** (around line 100 in apps array loop):
   - After parsing required fields (name, path, hostname), check for optional "env" field
   - If env exists and is a JSON object:
     a. Create `std.StringHashMap([]const u8).init(allocator)`
     b. Iterate JSON object entries with errdefer cleanup
     c. For each string entry: `allocator.dupe()` both key and value
     d. Put into HashMap
   - If no env field or not an object: set to null
   - Set app.env = env_map (or null)

3. **Config.deinit cleanup** (line 26):
   - Before freeing app fields, check if app.env is non-null
   - If env exists:
     a. Iterate HashMap entries
     b. Free both key and value strings: `self.allocator.free(entry.key_ptr.*)`
     c. Call `var_map.deinit()` on mutable copy
   - Then continue existing cleanup

**Pattern to follow:** Match existing optional field parsing (defaults, timeout_ms) - check JSON field, parse if exists, set to null/default if not.

**Error handling:** Use errdefer to cleanup partially allocated HashMap on parse errors. Return ParseError.OutOfMemory if allocations fail.

**Memory safety:** All strings must be duped (owned by config allocator). HashMap keys and values freed in deinit before HashMap itself.
  </action>
  <verify>
Build succeeds: `zig build`

Create test config: `test/env-test/nano.json`
```json
{
  "port": 8080,
  "apps": [{
    "name": "test-app",
    "path": "./test/apps/basic",
    "hostname": "test.local",
    "env": {
      "API_KEY": "secret123",
      "DEBUG": "true"
    }
  }]
}
```

Parse test: `zig build test` - config parsing tests pass
  </verify>
  <done>
- AppConfig struct has env field (optional StringHashMap)
- parseConfig correctly parses env object from JSON into HashMap
- Missing env field results in null (no crash)
- Config.deinit frees all env HashMap strings without memory leaks
  </done>
</task>

<task type="auto">
  <name>Task 2: Pass Environment Variables to Fetch Handler with Owned Copy</name>
  <files>src/server/app.zig</files>
  <action>
Modify App struct and handleRequest to pass environment variables as second parameter to fetch handler. CRITICAL: App must own its own HashMap copy to prevent use-after-free on hot reload.

1. **App struct** (around line 28):
   - Add field: `env: std.StringHashMap([]const u8)`
   - App OWNS this HashMap (not a reference to AppConfig.env)
   - Always initialized (empty if no env in config)

2. **loadApp function** (where App is initialized):
   - After storing timeout_ms and memory_limit_mb from AppConfig
   - Initialize: `app.env = std.StringHashMap([]const u8).init(self.allocator)`
   - If `app_config.env` is non-null, copy entries:
     ```zig
     if (app_config.env) |config_env| {
         var it = config_env.iterator();
         while (it.next()) |entry| {
             const key_copy = try self.allocator.dupe(u8, entry.key_ptr.*);
             errdefer self.allocator.free(key_copy);
             const val_copy = try self.allocator.dupe(u8, entry.value_ptr.*);
             errdefer self.allocator.free(val_copy);
             try app.env.put(key_copy, val_copy);
         }
     }
     ```
   - **Why copy instead of reference:** AppConfig is freed after reloadConfig (http.zig:190). Shallow copy creates dangling pointer. Deep copy ensures App owns its data and survives config reload.

3. **App.deinit** (add cleanup):
   - Iterate `self.env` entries
   - Free both key and value: `self.allocator.free(entry.key_ptr.*)` and `self.allocator.free(entry.value_ptr.*)`
   - Call `self.env.deinit()`

4. **buildEnvObject helper function** (new, before handleRequest):
```zig
/// Build V8 object from app environment variables
fn buildEnvObject(
    isolate: v8.Isolate,
    context: v8.Context,
    app_env: *const std.StringHashMap([]const u8),
) v8.Object {
    const js = @import("js");
    const env_obj = js.object(isolate, context);

    var it = app_env.iterator();
    while (it.next()) |entry| {
        const key_str = v8.String.initUtf8(isolate, entry.key_ptr.*);
        const val_str = v8.String.initUtf8(isolate, entry.value_ptr.*);
        _ = env_obj.setValue(context, key_str, val_str.toValue());
    }

    return env_obj;
}
```

5. **handleRequest modification** (where fetch handler is called):
   - Find: `var fetch_args: [1]v8.Value = ...`
   - Before calling fetch_fn.call(), add:
     `const env_obj = buildEnvObject(isolate, context, &self.env);`
   - Change to: `var fetch_args: [2]v8.Value = .{`
     `v8.Value{ .handle = @ptrCast(request_obj.handle) },`
     `v8.Value{ .handle = @ptrCast(env_obj.handle) },`
     `};`
   - Keep existing fetch_fn.call() with updated fetch_args

**Pattern to follow:** Match Request object creation pattern (src/api/request.zig) - use js.object(), js.setProp() patterns for V8 object creation.

**Isolation guarantee:** buildEnvObject creates fresh V8 object per request. No caching, no persistent handles. Each app gets only its own env HashMap.

**Hot reload safety:** When http.zig calls reloadConfig and updateApp/addApp re-creates App, new App gets fresh copy of new config's env. Old App is deinitialized (freeing its env HashMap copy). No use-after-free possible.
  </action>
  <verify>
Build succeeds: `zig build`

Manual test:
1. Create test app `test/apps/env-test/index.js`:
```javascript
export default {
  async fetch(request, env) {
    return new Response(JSON.stringify({
      hasEnv: !!env,
      apiKey: env.API_KEY,
      debug: env.DEBUG
    }), {
      headers: { "content-type": "application/json" }
    });
  }
};
```

2. Run server: `./zig-out/bin/nano serve --config test/env-test/nano.json`
3. Test request: `curl -H "Host: test.local" http://localhost:8080/`
4. Response should show: `{"hasEnv":true,"apiKey":"secret123","debug":"true"}`
  </verify>
  <done>
- App struct owns its env HashMap (not a reference)
- loadApp copies HashMap entries from AppConfig into App-owned HashMap
- App.deinit frees env HashMap and all strings
- buildEnvObject creates V8 object from owned HashMap
- Fetch handler receives 2 arguments: (request, env)
- App can access env variables via second parameter
- Empty env object passed when no env defined (not undefined)
- No use-after-free on hot reload (App owns its data)
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Isolation, Hot Reload, and Memory Safety</name>
  <files>src/config.zig, src/server/app.zig</files>
  <action>
Create integration tests to verify environment variable isolation, hot reload, and memory safety (no use-after-free):

1. **Isolation test config** - `test/env-isolation/nano.json`:
```json
{
  "port": 8080,
  "apps": [
    {
      "name": "app-a",
      "path": "./test/apps/env-a",
      "hostname": "a.local",
      "env": { "API_KEY": "key-a", "APP_NAME": "A" }
    },
    {
      "name": "app-b",
      "path": "./test/apps/env-b",
      "hostname": "b.local",
      "env": { "API_KEY": "key-b", "APP_NAME": "B" }
    }
  ]
}
```

2. **Test apps** - Both apps return their env vars:
`test/apps/env-a/index.js`:
```javascript
export default {
  async fetch(request, env) {
    return new Response(JSON.stringify(env));
  }
};
```
(Same for env-b)

3. **Run isolation test**:
   - Start: `./zig-out/bin/nano serve --config test/env-isolation/nano.json`
   - Test A: `curl -H "Host: a.local" http://localhost:8080/`
     Expected: `{"API_KEY":"key-a","APP_NAME":"A"}`
   - Test B: `curl -H "Host: b.local" http://localhost:8080/`
     Expected: `{"API_KEY":"key-b","APP_NAME":"B"}`
   - Verify: No cross-contamination

4. **Hot reload test** (validates ENVV-04 and no use-after-free):
   - Modify `test/env-isolation/nano.json` while server running
   - Change app-a env: `"API_KEY": "key-a-updated"`
   - Wait 3 seconds (config watcher poll + debounce)
   - Test again: `curl -H "Host: a.local" http://localhost:8080/`
   - Expected: `{"API_KEY":"key-a-updated","APP_NAME":"A"}`
   - **Critical:** No crash or garbage data (proves no use-after-free)

5. **Memory leak test** (validates no use-after-free with valgrind/instruments):
   - Run: `zig build && leaks -atExit -- ./zig-out/bin/nano serve --config test/env-isolation/nano.json &`
   - Send requests, trigger hot reload multiple times, send more requests
   - Stop server, check for leaks
   - Expected: No "definitely lost" memory, no use-after-free errors
   - **What this proves:** App-owned HashMap copy prevents dangling pointer when AppConfig is freed

Document test results in commit message, specifically noting hot reload stability (no crash = use-after-free fixed).
  </action>
  <verify>
All tests pass:
- Isolation: App A and App B receive different env vars
- Hot reload: Modified env vars reflected in next request WITHOUT crash
- No crashes: Apps without env field still work
- Memory: No leaks or use-after-free detected in valgrind/instruments output
  </verify>
  <done>
- ENVV-01 validated: Config JSON supports env object per app
- ENVV-02 validated: Env vars passed as second fetch handler parameter
- ENVV-03 validated: Complete isolation between apps
- ENVV-04 validated: Env vars updated on config hot reload WITHOUT use-after-free
- Memory safety validated: No use-after-free when AppConfig freed during reload
  </done>
</task>

</tasks>

<verification>
**Requirements coverage:**
- ENVV-01: Config JSON supports `env` object per app definition ✓
- ENVV-02: Environment variables injected as second parameter to fetch handler ✓
- ENVV-03: Complete isolation — app A cannot access app B's env vars ✓
- ENVV-04: Env vars updated on config reload (hot reload support) ✓

**Integration checks:**
1. Build succeeds without errors
2. Apps with env vars can access them via second parameter
3. Apps without env receive empty object (not undefined/null)
4. Multiple apps have isolated env vars
5. Config hot reload updates env vars automatically WITHOUT crash
6. No memory leaks or use-after-free in valgrind/instruments

**Goal-backward verification (must_haves):**
- App can read environment variables via fetch handler second parameter
- Environment variables defined in config.json per app
- App A cannot access App B's environment variables (isolation)
- Environment variables update when config is hot-reloaded (no use-after-free)
</verification>

<success_criteria>
Phase v1.2-01 complete when:
- All 4 requirements (ENVV-01 through ENVV-04) validated
- Integration tests pass (isolation, hot reload, no crashes)
- No memory leaks or use-after-free detected
- Apps can access env vars following Cloudflare Workers pattern
- Config parsing handles both apps with env and without env
- Hot reload automatically propagates env changes safely (App owns HashMap copy)
</success_criteria>

<output>
After completion, create `.planning/phases/v1.2-01-per-app-env-vars/v1.2-01-01-SUMMARY.md`
</output>
