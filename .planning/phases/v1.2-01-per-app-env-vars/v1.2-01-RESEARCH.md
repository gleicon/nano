# Phase v1.2-01: Per-App Environment Variables - Research

**Researched:** 2026-02-02
**Domain:** V8 object creation, configuration parsing, request handling, multi-tenant isolation
**Confidence:** HIGH

## Summary

Per-app environment variables enable apps running on NANO to access isolated configuration without polluting the global scope. This phase requires extending the config format to support per-app `env` objects, creating V8 objects to pass to the fetch handler, and ensuring complete isolation between apps.

The implementation follows the Cloudflare Workers pattern: environment variables are passed as the second parameter (`env`) to the fetch handler. Each app receives only its own environment variables, and environment updates on hot-reload are automatically propagated.

The technical challenge is minimal: it's primarily a configuration parsing extension and a V8 object creation at request time. NANO already has the patterns in place from existing code (Request object creation, property setting, handler invocation). This is a low-risk, high-value feature.

**Primary recommendation:** Parse `env` object per-app in config, build V8 object on each request in `handleRequest`, pass as second parameter to fetch handler, store nothing in app isolate global scope for complete isolation.

## Standard Stack

This phase uses existing NANO patterns and Zig stdlib - no new libraries needed.

### Core
| Component | Source | Purpose | Why Standard |
|-----------|--------|---------|--------------|
| std.json parsing | Zig stdlib | Parse `env` object from config JSON | Already used for all config parsing |
| V8 Object creation | v8 API (existing) | Build env object in-memory | Already used for Request, Headers |
| js.object() helper | src/js.zig | Create empty V8 object | Existing utility for all APIs |
| js.setProp() helper | src/js.zig | Set environment variables | Existing utility, used in Request class |

### Supporting
| Component | Source | Purpose | When to Use |
|-----------|--------|---------|-------------|
| std.StringHashMap | Zig stdlib | Store env vars in AppConfig | Standard pattern for key-value data |
| v8.String.initUtf8() | v8 API | Create V8 strings for var names/values | Already used everywhere in codebase |

## Architecture Patterns

### Recommended Config Format Extension

**Current config.json:**
```json
{
  "port": 8080,
  "apps": [
    {
      "name": "app-a",
      "path": "./apps/app-a",
      "hostname": "a.local",
      "timeout_ms": 5000,
      "memory_mb": 64
    }
  ]
}
```

**New config.json with env:**
```json
{
  "port": 8080,
  "apps": [
    {
      "name": "app-a",
      "path": "./apps/app-a",
      "hostname": "a.local",
      "timeout_ms": 5000,
      "memory_mb": 64,
      "env": {
        "API_KEY": "secret123",
        "DEBUG": "true",
        "DATABASE_URL": "postgres://localhost/db"
      }
    },
    {
      "name": "app-b",
      "path": "./apps/app-b",
      "hostname": "b.local",
      "env": {
        "API_KEY": "different_secret_456",
        "DEBUG": "false"
      }
    }
  ]
}
```

**Key points:**
- `env` is optional (apps without env fields still work)
- Each app has isolated env vars - app-a cannot access app-b's vars
- All values are strings (Cloudflare Workers standard)
- Values support any JSON string content (no special parsing)

### Pattern 1: AppConfig Struct Extension

**Location:** `src/config.zig`

**Current:**
```zig
pub const AppConfig = struct {
    name: []const u8,
    path: []const u8,
    hostname: []const u8,
    port: u16,
    timeout_ms: u64,
    memory_mb: usize,
};
```

**New:**
```zig
pub const AppConfig = struct {
    name: []const u8,
    path: []const u8,
    hostname: []const u8,
    port: u16,
    timeout_ms: u64,
    memory_mb: usize,
    env: ?std.StringHashMap([]const u8),  // NEW: null if no env defined
};
```

**Rationale:**
- StringHashMap provides O(1) lookups and iteration
- Optional (`?`) since env is not required
- Stores as strings (matching Cloudflare Workers semantics)
- HashMap ownership is per-AppConfig (cleanup in Config.deinit)

### Pattern 2: Config Parsing for Env Object

**Location:** `src/config.zig` in `parseConfig()` function

**Logic flow:**
```
for each app in JSON:
  1. Parse required fields (name, path, hostname)
  2. Check for optional "env" object in JSON
  3. If env exists:
     a. Create StringHashMap allocator
     b. For each key:value pair in JSON object:
        - Store as (owned string key, owned string value)
     c. Assign to AppConfig.env
  4. If no env field:
     - Set AppConfig.env = null
  5. Store remaining config fields
```

**Example implementation pattern:**
```zig
// In parseConfig() when processing each app
var env_map: ?std.StringHashMap([]const u8) = null;

if (app_obj.get("env")) |env_val| {
    if (env_val.object) |env_obj| {  // Only if it's an object
        var map = std.StringHashMap([]const u8).init(allocator);

        var it = env_obj.iterator();
        while (it.next()) |entry| {
            if (entry.value_ptr.* == .string) {
                const key = allocator.dupe(u8, entry.key_ptr.*) catch return ParseError.OutOfMemory;
                const value = allocator.dupe(u8, entry.value_ptr.*.string) catch {
                    allocator.free(key);
                    return ParseError.OutOfMemory;
                };
                map.put(key, value) catch return ParseError.OutOfMemory;
            }
        }

        env_map = map;
    }
}

apps[i].env = env_map;
```

**Cleanup in Config.deinit():**
```zig
for (self.apps) |app| {
    if (app.env) |env_map| {
        var it = env_map.iterator();
        while (it.next()) |entry| {
            self.allocator.free(entry.key_ptr.*);
            self.allocator.free(entry.value_ptr.*);
        }
        env_map.deinit();  // Requires mutable reference - use copy pattern
    }
    // ... existing cleanup
}
```

### Pattern 3: Request-Time Env Object Creation

**Location:** `src/server/app.zig` in `handleRequest()` function

**What:** Create a V8 object containing env vars, pass as second parameter to fetch handler.

**Before (current handleRequest):**
```zig
// Create Request object
const request_obj = request_api.createRequest(isolate, context, full_url, method, body);

// Call the cached fetch handler - 1 argument
var fetch_args: [1]v8.Value = .{v8.Value{ .handle = @ptrCast(request_obj.handle) }};
const handler_result = fetch_fn.call(context, exports, &fetch_args) orelse { ... };
```

**After (with env parameter):**
```zig
// Create Request object
const request_obj = request_api.createRequest(isolate, context, full_url, method, body);

// Create env object from app config
const env_obj = try buildEnvObject(isolate, context, app.env);

// Call the cached fetch handler - 2 arguments
var fetch_args: [2]v8.Value = .{
    v8.Value{ .handle = @ptrCast(request_obj.handle) },
    v8.Value{ .handle = @ptrCast(env_obj.handle) },
};
const handler_result = fetch_fn.call(context, exports, &fetch_args) orelse { ... };
```

**Helper function:**
```zig
/// Build a V8 object from app env vars
fn buildEnvObject(
    isolate: v8.Isolate,
    context: v8.Context,
    app_env: ?std.StringHashMap([]const u8),
) !v8.Object {
    const env_obj = js.object(isolate, context);

    if (app_env) |env_vars| {
        var it = env_vars.iterator();
        while (it.next()) |entry| {
            const key_str = v8.String.initUtf8(isolate, entry.key_ptr.*);
            const val_str = v8.String.initUtf8(isolate, entry.value_ptr.*);
            _ = env_obj.setValue(context, key_str, val_str.toValue());
        }
    }

    return env_obj;
}
```

**Key points:**
- Creates fresh object per request (no reuse, no caching)
- Environment isolation: each app's object is independent
- Only populated vars are included (no undefined entries)
- Passed as V8 Value, not stored in isolate globals

### Pattern 4: Hot Reload Propagation

**Location:** `src/runtime/event_loop.zig` in config reload callback

**What:** When config is reloaded, env vars are automatically updated because they're passed per-request.

**How it works:**
1. ConfigWatcher detects config file change
2. `reloadConfig()` parses new config
3. Creates new AppConfig with new `env` HashMap
4. HttpServer swaps old AppConfig for new AppConfig in HashMap
5. Next request to that app calls `buildEnvObject()` with new env vars
6. No app code changes needed - automatic

**No additional code needed** - the pattern naturally supports hot reload because env is built fresh on each request.

## Don't Hand-Roll

Problems that look simple but have critical gotchas:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Custom env object type | `struct with individual fields` | `StringHashMap([]const u8)` | HashMap scales to any number of vars, simple iteration |
| Global env object registered on isolate | `globalThis.process.env` | Pass as parameter | Global state breaks isolation - app A could access app B's vars if somehow shared |
| Hardcoded var names | Check each var explicitly | Iterate all vars from HashMap | Flexible for any number of vars, supports arbitrary var names |
| Environment caching across requests | Store env in App struct | Rebuild per request | Dynamic updates from hot-reload require fresh build each time |

**Key insight:** Passing env as a parameter (not storing on isolate) is essential for multi-tenant isolation. If any app could access `globalThis.env`, it might be exposed to sibling apps during error cases or debugging.

## Common Pitfalls

### Pitfall 1: Environment Leakage Between Apps

**What goes wrong:** App A reads an environment variable and gets App B's value instead.

**Why it happens:**
- Registering env on global object (`globalThis.env`) instead of parameter
- Sharing HashMap reference between apps without copying
- Reusing V8 object across requests without rebuilding

**How to avoid:**
- Pass env as second parameter to fetch handler (explicit, not implicit global)
- Create fresh V8 object on each request (never cache)
- Verify no global registration of env vars
- Test: Start server with two apps with different API_KEY values, verify isolation

**Warning signs:**
- `js.addGlobalClass(..., "env", ...)` being called
- App struct storing `persistent_env: v8.Persistent(v8.Object)`
- Same env object passed to multiple requests

### Pitfall 2: Config Reload Not Updating Environment

**What goes wrong:** After changing config.json, app still uses old env vars.

**Why it happens:**
- Caching env object in App struct
- Failing to parse env from new config on reload
- Not deallocating old StringHashMap before replacing

**How to avoid:**
- Never store env in App struct - only in AppConfig
- Always rebuild env object from AppConfig on each request
- In config reload, AppConfig gets new HashMap, old one is deallocated
- Test: Modify config.json, add new env var, verify next request sees new var

**Warning signs:**
- `app.env: StringHashMap(...)` in App struct
- `persistent_env` handles anywhere
- Env var access outside of handleRequest function

### Pitfall 3: StringHashMap Cleanup on Config Deinit

**What goes wrong:** Memory leak - env HashMap is not properly freed during config reload.

**Why it happens:**
- HashMap stores owned strings - both keys and values must be freed
- Iterator must be used correctly (mutable/immutable)
- Old AppConfig not fully deallocated before replacement

**How to avoid:**
- In Config.deinit(), iterate all apps and free env vars explicitly
- Free both key and value strings before deinit()
- Test with valgrind: `zig build && valgrind ./zig-out/bin/nano serve --config test/multi-app/nano.json`
- Verify no "definitely lost" memory in valgrind output

**Warning signs:**
- Compiler error on `env_map.deinit()` (needs mutable reference)
- HashMap iterator panicking on deinit
- Valgrind showing "definitely lost" after config reload

### Pitfall 4: No Env Field in Config

**What goes wrong:** App crashes when accessing `env` parameter if config doesn't have env field.

**Why it happens:**
- `env` is optional (null if not defined) but handler expects object
- Handler code tries to access properties on null

**How to avoid:**
- Always set `env` to empty object {} even if not defined
- In buildEnvObject(), pass empty object when app_env is null
- Test: Create config without any env fields, verify apps still work
- Test: Mix apps - some with env, some without

**Warning signs:**
- Handler code like `env.API_KEY` (should check if env exists)
- Config parsing returns null for missing env
- Error messages about "cannot read property of null/undefined"

### Pitfall 5: Type Confusion - StringHashMap Iteration

**What goes wrong:** Cannot iterate StringHashMap or accidentally modifying it during iteration.

**Why it happens:**
- HashMap requires correct iterator type
- Zig's HashMap has specific mutation rules
- Off-by-one errors in key/value parsing

**How to avoid:**
- Use `HashMap.iterator()` to get immutable iterator
- Don't modify map while iterating
- In config parsing: build new map, don't modify existing one
- In buildEnvObject(): only read from map, never modify

**Warning signs:**
- `env_vars.iterator()` compilation error
- Panics about "concurrent modification"
- Iterator returning wrong keys/values

## Code Examples

Verified patterns from existing NANO code.

### Example 1: Creating V8 Object with Properties

**Source:** `src/api/request.zig` (Request constructor pattern)

```zig
// Pattern: Create object and set properties
const env_obj = js.object(isolate, context);

const api_key = v8.String.initUtf8(isolate, "API_KEY");
const api_value = v8.String.initUtf8(isolate, "secret123");
_ = env_obj.setValue(context, api_key, api_value.toValue());

const debug = v8.String.initUtf8(isolate, "DEBUG");
const debug_value = v8.String.initUtf8(isolate, "true");
_ = env_obj.setValue(context, debug, debug_value.toValue());

// Return to JavaScript - env.API_KEY is now "secret123"
```

This exact pattern is already used in `registerRequestAPI()` to create Request objects with properties. Simply iterate over AppConfig.env HashMap instead of hardcoding.

### Example 2: Parsing JSON Object into HashMap

**Source:** `src/config.zig` (existing config parsing pattern)

```zig
// Pattern: Parse JSON object into StringHashMap
var env_map = std.StringHashMap([]const u8).init(allocator);
errdefer {
    // Cleanup on error: free keys and values
    var it = env_map.iterator();
    while (it.next()) |entry| {
        allocator.free(entry.key_ptr.*);
        allocator.free(entry.value_ptr.*);
    }
    env_map.deinit();
}

var it = json_object.iterator();
while (it.next()) |entry| {
    if (entry.value_ptr.* == .string) {
        const key = allocator.dupe(u8, entry.key_ptr.*) catch return ParseError.OutOfMemory;
        errdefer allocator.free(key);

        const value = allocator.dupe(u8, entry.value_ptr.*.string) catch return ParseError.OutOfMemory;
        errdefer allocator.free(value);

        try env_map.put(key, value);
    }
}

app_config.env = env_map;
```

This follows the existing pattern in `parseConfig()` for parsing optional fields with error handling.

### Example 3: Modifying Handler Invocation to Pass Two Parameters

**Source:** `src/server/app.zig` (existing handleRequest pattern)

```zig
// Current: Pass request as first argument
const request_obj = request_api.createRequest(isolate, context, full_url, method, body);
var fetch_args: [1]v8.Value = .{v8.Value{ .handle = @ptrCast(request_obj.handle) }};
const handler_result = fetch_fn.call(context, exports, &fetch_args) orelse { /* error */ };

// New: Pass request and env as two arguments
const request_obj = request_api.createRequest(isolate, context, full_url, method, body);
const env_obj = try buildEnvObject(isolate, context, app.env);
var fetch_args: [2]v8.Value = .{
    v8.Value{ .handle = @ptrCast(request_obj.handle) },
    v8.Value{ .handle = @ptrCast(env_obj.handle) },
};
const handler_result = fetch_fn.call(context, exports, &fetch_args) orelse { /* error */ };
```

The pattern is already used in fetch.zig for calling JavaScript callbacks with multiple arguments.

### Example 4: JavaScript App Accessing Environment Variables

**How apps use it:**
```javascript
// App code (e.g., apps/my-app/index.js)
export default {
  async fetch(request, env) {
    const apiKey = env.API_KEY;
    const dbUrl = env.DATABASE_URL;

    const response = await fetch(`${env.API_HOST}/api/data`, {
      headers: { "Authorization": `Bearer ${apiKey}` }
    });

    return response;
  }
};
```

Apps simply receive `env` as second parameter and access vars by name. No special API needed.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single app, process.env | Per-app env param | Cloudflare Workers standard | Required for multi-tenant isolation |
| Global object registration | Parameter-based injection | WinterCG patterns | Prevents cross-app leakage |
| Hardcoded secrets in code | Config-driven env vars | Industry standard practice | Enables secrets management |

**Deprecated/outdated:**
- Storing environment in V8 global object (breaks isolation)
- Process-wide environment variables (not multi-tenant safe)
- Hardcoded configuration (prevents dynamic updates)

## Implementation Dependencies

### Required from Prior Phases
- **v1.1-01: Multi-App Server** - Multiple apps running, app routing working
- **v1.1-02: App Lifecycle & Hot Reload** - Config watching and reload infrastructure exists

### Not Required for This Phase
- Streams API (v1.2-02) - No dependency
- Graceful Shutdown (v1.2-03) - No dependency

This phase can be implemented independently of other v1.2 features.

## Implementation Checklist

### Config Extension (src/config.zig)
- [ ] Add `env: ?std.StringHashMap([]const u8)` to AppConfig struct
- [ ] Parse "env" object from JSON if present
- [ ] Create StringHashMap, populate with string key-value pairs
- [ ] Handle missing env field (set to null)
- [ ] Add cleanup in Config.deinit() - free HashMap and all strings
- [ ] Test: Config with env, without env, mixed apps

### App struct changes (src/server/app.zig)
- [ ] Add `env: ?std.StringHashMap([]const u8)` field to App (copy from AppConfig)
- [ ] Modify loadApp() to accept and store env from AppConfig
- [ ] Add buildEnvObject() helper function
- [ ] Modify handleRequest() signature: pass app config or env separately
- [ ] Change fetch handler invocation to pass 2 arguments: (request, env)
- [ ] Test: Handler receives env, can access variables

### Request Handler Tests
- [ ] App with env vars can access them
- [ ] App without env receives empty object
- [ ] Multiple apps have isolated env vars
- [ ] Env vars update on config reload
- [ ] All env values are strings

### Memory/Cleanup Tests
- [ ] No memory leaks when config reloaded (valgrind)
- [ ] StringHashMap properly freed on Config.deinit()
- [ ] Old app env freed before replacement

## Open Questions

None at this time. The architecture is straightforward and follows established patterns in NANO codebase.

## Sources

### Primary (HIGH confidence)
- [Cloudflare Workers Fetch Handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) - Defines fetch(request, env, ctx) signature
- [Cloudflare Workers Environment Variables](https://developers.cloudflare.com/workers/configuration/environment-variables/) - Config format and access patterns
- NANO v1.1 source code (`src/config.zig`, `src/server/app.zig`, `src/api/request.zig`) - Verified patterns for config parsing, V8 object creation, handler invocation

### Architecture Research (HIGH confidence)
- `/Users/gleicon/code/zig/nano/.planning/research/ARCHITECTURE.md` - Documented v1.2 integration approach for environment variables
- NANO v1.1-02 RESEARCH.md - Config watching patterns already verified

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using existing Zig stdlib and proven V8 patterns
- Architecture: HIGH - Follows established Cloudflare Workers semantics
- Pitfalls: HIGH - Based on multi-tenant isolation principles
- Implementation: HIGH - Verified against existing NANO code patterns

**Research date:** 2026-02-02
**Valid until:** 2026-03-02 (30 days - stable feature, no rapid iteration expected)
**Tech Stack Stability:** Zig stdlib stable, V8 patterns tested in v1.1, config parsing proven
