# Stack Research: v1.2 Production Polish

**Project:** NANO - Ultra-dense JavaScript runtime with V8 isolates
**Researched:** 2026-02-02
**Overall Confidence:** MEDIUM-HIGH

---

## Executive Summary

This research covers stack additions for v1.2 features: WinterCG Streams API, per-app environment variables, graceful shutdown with connection draining, and documentation website. The key finding is that **Streams should use a JavaScript polyfill rather than native C++ bindings** due to complexity/time tradeoffs, while graceful shutdown requires modifications to the existing HTTP server to handle connection draining properly.

---

## 1. Streams Implementation

### Approach Decision: JavaScript Polyfill vs Native Bindings

| Approach | Effort | Performance | WinterCG Compliance | Recommendation |
|----------|--------|-------------|---------------------|----------------|
| **JavaScript Polyfill** | LOW (1-2 days) | Good for most cases | HIGH (spec-aligned) | **RECOMMENDED** |
| Native C++ Bindings (workerd-style) | VERY HIGH (weeks) | Optimal | HIGH | Not for v1.2 |
| Hybrid (JS + native fast path) | HIGH | Best | HIGH | Future v2 option |

**Rationale:** Cloudflare workerd and Deno both use native bindings for streams, but these are deeply integrated C++/Rust implementations requiring significant infrastructure. For NANO v1.2, using [web-streams-polyfill](https://github.com/MattiasBuelens/web-streams-polyfill) provides WinterCG-compliant streams with minimal integration effort.

### Recommended: web-streams-polyfill

**Version:** 4.2.0 (August 2025)
**License:** MIT
**Spec Version:** Implements WHATWG Streams spec version 080852c (April 2025)

**Why this polyfill:**
- Pure JavaScript, no native dependencies
- Passes web platform tests used by browsers
- Actively maintained (33 releases)
- Used by other V8 embedding runtimes (cloudworker, Fly.io v8env)

**Installation approach:**
```javascript
// Bundle the ponyfill variant into NANO's runtime bootstrap
import {
  ReadableStream,
  WritableStream,
  TransformStream,
  ReadableStreamDefaultReader,
  ReadableStreamBYOBReader,
  WritableStreamDefaultWriter,
  ByteLengthQueuingStrategy,
  CountQueuingStrategy
} from "web-streams-polyfill";

// Expose on global object
globalThis.ReadableStream = ReadableStream;
globalThis.WritableStream = WritableStream;
globalThis.TransformStream = TransformStream;
// ... etc
```

### WinterTC Minimum Common API Requirements

Per the [WinterTC Minimum Common API specification](https://min-common-api.proposal.wintertc.org/), NANO must implement:

**Required Streams Interfaces:**
- `ReadableStream`, `WritableStream`, `TransformStream`
- `ReadableStreamDefaultController`, `ReadableByteStreamController`
- `WritableStreamDefaultController`, `TransformStreamDefaultController`
- `ReadableStreamDefaultReader`, `ReadableStreamBYOBReader`
- `ByteLengthQueuingStrategy`, `CountQueuingStrategy`

**Compression Streams (can defer to v1.3):**
- `CompressionStream`, `DecompressionStream`

### Integration with Existing NANO APIs

The current `Request` and `Response` implementations store body as strings (`_body` property). For streams integration:

1. **Phase 1 (v1.2):** Add streams as standalone globals, body remains string-based
2. **Phase 2 (future):** Integrate with Request.body returning ReadableStream

```javascript
// v1.2: Streams work standalone
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("chunk1");
    controller.enqueue("chunk2");
    controller.close();
  }
});

// Future: Request.body integration
const body = request.body; // Returns ReadableStream
```

### Confidence: MEDIUM-HIGH

- HIGH confidence on polyfill approach working
- MEDIUM confidence on performance being acceptable (may need native fast paths later)

**Sources:**
- [web-streams-polyfill GitHub](https://github.com/MattiasBuelens/web-streams-polyfill)
- [WHATWG Streams Standard](https://streams.spec.whatwg.org/)
- [WinterTC Minimum Common API](https://min-common-api.proposal.wintertc.org/)
- [Cloudflare workerd streams](https://github.com/cloudflare/workerd)
- [Deno fast streams](https://github.com/denoland/deno/issues/16046)

---

## 2. Per-App Environment Variables

### Current State

The existing `config.zig` supports per-app configuration:
```zig
pub const AppConfig = struct {
    name: []const u8,
    path: []const u8,
    hostname: []const u8,
    port: u16,
    timeout_ms: u64,
    memory_mb: usize,
    // NO env vars field currently
};
```

### Recommended Implementation

**Config format extension:**
```json
{
  "apps": [
    {
      "name": "my-app",
      "path": "./apps/my-app",
      "hostname": "myapp.local",
      "env": {
        "DATABASE_URL": "postgres://...",
        "API_KEY": "secret123",
        "NODE_ENV": "production"
      }
    }
  ]
}
```

**Zig struct addition:**
```zig
pub const AppConfig = struct {
    // ... existing fields ...
    env: std.StringHashMap([]const u8), // Key-value pairs
};
```

**JavaScript API:**
```javascript
// Exposed in isolate context
const dbUrl = env.DATABASE_URL;
// Or via Deno-style API
const dbUrl = Deno.env.get("DATABASE_URL");
```

### Isolation Requirements

Per-app env vars MUST be isolated:
- App A cannot read App B's env vars
- Env vars injected at isolate creation time
- No access to host system env vars (security)

### Implementation Notes

1. Parse `env` object in `parseConfig()`
2. Store in `AppConfig.env` HashMap
3. Inject into V8 context during app initialization (`script.zig`)
4. Create global `env` object or `Deno.env` polyfill

### Confidence: HIGH

This is straightforward JSON parsing and V8 global injection. No external dependencies.

---

## 3. Graceful Shutdown with Connection Draining

### Current State Analysis

The existing `http.zig` has basic signal handling:
```zig
fn handleSignal(_: c_int) callconv(.c) void {
    if (global_server) |s| {
        s.stop();
    }
}

pub fn stop(self: *HttpServer) void {
    self.running = false;
    // Wake accept() with dummy connection
    const wake_conn = std.net.tcpConnectToAddress(self.address) catch null;
    if (wake_conn) |conn| {
        conn.close();
    }
}
```

**Problem:** Current implementation stops immediately without waiting for in-flight requests.

### Graceful Shutdown Pattern

The standard pattern for HTTP server graceful shutdown:

1. **Receive SIGTERM/SIGINT**
2. **Stop accepting new connections** (close listening socket or reject)
3. **Wait for in-flight requests** with timeout (30-60 seconds typical)
4. **Send `Connection: close`** header on all responses during drain
5. **Force terminate** remaining connections after timeout
6. **Exit process**

### Recommended Implementation

```zig
pub const HttpServer = struct {
    // ... existing fields ...
    draining: bool = false,
    active_requests: std.atomic.Value(u32) = std.atomic.Value(u32).init(0),
    drain_timeout_ms: u64 = 30000, // 30 second default

    pub fn gracefulShutdown(self: *HttpServer) void {
        self.draining = true;

        // Stop accepting new connections
        self.running = false;

        // Wait for active requests with timeout
        const start = std.time.milliTimestamp();
        while (self.active_requests.load(.seq_cst) > 0) {
            if (std.time.milliTimestamp() - start > self.drain_timeout_ms) {
                // Timeout reached, force close remaining
                break;
            }
            std.time.sleep(10 * std.time.ns_per_ms); // 10ms poll
        }

        // Log drain statistics
        var logger = log.stdout();
        logger.info("graceful_shutdown_complete", .{
            .drained_requests = self.metrics.request_count,
            .forced_closed = self.active_requests.load(.seq_cst),
        });
    }
};
```

### Connection Draining for App Removal

When removing an app via admin API or config reload:
1. Mark app as "draining"
2. Route new requests for that hostname to 503 Service Unavailable
3. Wait for in-flight requests to that app to complete
4. Then cleanup isolate

```zig
pub fn removeAppGracefully(self: *HttpServer, hostname: []const u8) void {
    if (self.apps.get(hostname)) |app_ptr| {
        app_ptr.draining = true;

        // Wait for app's active requests
        while (app_ptr.active_requests.load(.seq_cst) > 0) {
            self.event_loop.tick() catch {};
            std.time.sleep(10 * std.time.ns_per_ms);
        }

        // Now safe to remove
        self.removeApp(hostname);
    }
}
```

### Known Issues with std.net.Server

Per [Zig issue #19445](https://github.com/ziglang/zig/issues/19445), `std.posix.accept` does not return on SIGTERM because the accept function loops on EINTR. The current workaround (dummy connection) works but is not ideal.

**Alternative:** Use poll() with timeout on the listening socket, checking `draining` flag periodically. This requires not using `std.http.Server` directly.

### Confidence: MEDIUM-HIGH

- HIGH confidence on the pattern
- MEDIUM confidence on Zig std lib interactions (may need workarounds)

**Sources:**
- [http.zig graceful shutdown example](https://github.com/karlseguin/http.zig)
- [Zig std.posix.accept issue](https://github.com/ziglang/zig/issues/19445)
- [Graceful shutdown patterns](https://medium.com/@harshgharat663/graceful-shutdown-in-backend-systems-dcba48e393af)

---

## 4. Documentation Website (Astro + Starlight)

### Recommended Stack

| Component | Version | Purpose |
|-----------|---------|---------|
| **Astro** | 5.x (current stable) | Static site framework |
| **Starlight** | 0.37.2 (Jan 2026) | Documentation theme |
| **Node.js** | 18+ | Build tooling |

### Why Starlight

- Official Astro documentation theme
- Used by Cloudflare, Google, Microsoft, OpenAI for docs
- Built-in features: search, navigation, dark mode, i18n
- Zero-config for basic setup
- Upcoming v1.0 release planned for 2026

### Project Setup

```bash
# Create docs site in /docs directory
npm create astro@latest -- --template starlight docs

# Directory structure
nano/
  docs/
    astro.config.mjs
    src/
      content/
        docs/
          getting-started.md
          api/
            fetch.md
            request.md
            response.md
          guides/
            multi-app.md
            env-vars.md
```

### Configuration (astro.config.mjs)

```javascript
import { defineConfig } from 'astro/config';
import starlight from '@astrojs/starlight';

export default defineConfig({
  integrations: [
    starlight({
      title: 'NANO',
      social: {
        github: 'https://github.com/your-org/nano',
      },
      sidebar: [
        { label: 'Getting Started', link: '/getting-started/' },
        {
          label: 'API Reference',
          items: [
            { label: 'fetch()', link: '/api/fetch/' },
            { label: 'Request', link: '/api/request/' },
            { label: 'Response', link: '/api/response/' },
            { label: 'Headers', link: '/api/headers/' },
            { label: 'Streams', link: '/api/streams/' },
          ],
        },
        {
          label: 'Guides',
          items: [
            { label: 'Multi-App Hosting', link: '/guides/multi-app/' },
            { label: 'Environment Variables', link: '/guides/env-vars/' },
            { label: 'WinterCG Compatibility', link: '/guides/wintercg/' },
          ],
        },
      ],
    }),
  ],
});
```

### Deployment Options

| Platform | Pros | Cons | Recommendation |
|----------|------|------|----------------|
| **GitHub Pages** | Free, integrated with repo | Manual gh-pages branch setup | Good for OSS |
| **Vercel** | Zero-config, fast CDN | External service | **RECOMMENDED** |
| **Netlify** | Zero-config, branch deploys | External service | Good alternative |

**Recommendation:** Vercel for easiest setup with automatic deployments on push.

### Content Structure for NANO

Recommended documentation sections:

1. **Getting Started**
   - Installation
   - Quick Start
   - Configuration

2. **API Reference** (WinterCG-aligned)
   - fetch()
   - Request / Response
   - Headers
   - URL / URLSearchParams
   - Streams (ReadableStream, WritableStream)
   - Console
   - Crypto
   - TextEncoder / TextDecoder

3. **Guides**
   - Multi-App Hosting
   - Virtual Host Routing
   - Environment Variables
   - Hot Reload
   - Admin API
   - Graceful Shutdown

4. **Architecture**
   - V8 Isolates
   - Memory Management
   - Event Loop

### Confidence: HIGH

Astro + Starlight is well-documented and straightforward to set up.

**Sources:**
- [Starlight Getting Started](https://starlight.astro.build/getting-started/)
- [Astro Deploy Guide](https://docs.astro.build/en/guides/deploy/)
- [Astro 2025 Year in Review](https://astro.build/blog/year-in-review-2025/)

---

## Integration Notes

### How These Fit with Existing NANO Architecture

| Feature | Integration Point | Complexity |
|---------|------------------|------------|
| Streams | `script.zig` bootstrap, new `api/streams.zig` | LOW |
| Env Vars | `config.zig` parsing, `app.zig` injection | LOW |
| Graceful Shutdown | `http.zig` server loop, signal handling | MEDIUM |
| Docs | Separate `/docs` directory, no runtime changes | LOW |

### Dependency Changes

**New npm dependencies (docs only):**
```json
{
  "devDependencies": {
    "astro": "^5.0.0",
    "@astrojs/starlight": "^0.37.0"
  }
}
```

**Bundled JavaScript (runtime):**
- web-streams-polyfill (bundled into bootstrap, not npm dependency)

**No new Zig dependencies required.**

### Build Integration

The docs site should be separate from the Zig build:
```bash
# Zig runtime
zig build

# Docs site
cd docs && npm run build
```

---

## What NOT to Add

| Alternative | Why NOT |
|-------------|---------|
| Native C++ streams bindings | Too complex for v1.2 timeline, polyfill sufficient |
| http.zig library | Current std.net.Server works, switching adds risk |
| Custom docs generator | Starlight is battle-tested, don't reinvent |
| Node.js-style process.env | Workers API uses env binding, not process.env |
| System env var access | Security risk, apps should only see configured vars |

---

## Open Questions for Implementation

### HIGH Priority

1. **Streams polyfill bundling:** Should we bundle the polyfill into the binary or load from file?
   - Recommendation: Embed as string in Zig, inject during context creation

2. **Drain timeout configurability:** Should drain timeout be configurable per-app or global?
   - Recommendation: Global config with per-app override option

### MEDIUM Priority

3. **Compression streams:** Include in v1.2 or defer to v1.3?
   - Recommendation: Defer, focus on core ReadableStream/WritableStream first

4. **Request.body as stream:** Implement in v1.2 or defer?
   - Recommendation: Defer, v1.2 adds standalone streams API only

---

## Summary: v1.2 Stack Additions

| Component | Choice | Version | Confidence |
|-----------|--------|---------|------------|
| Streams | web-streams-polyfill | 4.2.0 | MEDIUM-HIGH |
| Env Vars | Native Zig HashMap | N/A | HIGH |
| Graceful Shutdown | Custom in http.zig | N/A | MEDIUM-HIGH |
| Docs Framework | Astro + Starlight | 5.x + 0.37.x | HIGH |
| Docs Deployment | Vercel | N/A | HIGH |

**Total new runtime dependencies:** 0 (polyfill bundled)
**Total new build dependencies:** 2 npm packages (docs only)
